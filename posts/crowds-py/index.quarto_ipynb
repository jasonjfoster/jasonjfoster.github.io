{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a06a0396",
   "metadata": {},
   "source": [
    "---\n",
    "title: \"Crowds\"\n",
    "author: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\n",
    "date: last-modified\n",
    "categories:\n",
    "  - analysis\n",
    "  - finance\n",
    "  - python\n",
    "draft: true\n",
    "execute:\n",
    "  freeze: false\n",
    "editor: \n",
    "  mode: source\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "bc088dfd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# factors_r = [\"SP500\"] # \"SP500\" does not contain dividends\n",
    "# factors_d = [\"DTB3\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "8d1cbd2d",
   "metadata": {},
   "outputs": [],
   "source": [
    "#| echo: false\n",
    "# exec(open(\"posts/helper-levels.py\").read()) # local\n",
    "# exec(open(\"../helper-levels.py\").read())\n",
    "# width = 20 * 3"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "919f86f4",
   "metadata": {},
   "source": [
    "# Parse web"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "5055a8b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import yfscreen as yfs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "3cc722f0",
   "metadata": {},
   "outputs": [],
   "source": [
    "filters = [\"eq\", [\"categoryname\", \"Tactical Allocation\"]]\n",
    "query = yfs.create_query(filters)\n",
    "payload = yfs.create_payload(\"mutualfund\", query, 250)\n",
    "data = yfs.get_data(payload)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "117d9971",
   "metadata": {},
   "outputs": [],
   "source": [
    "sorted_df = data.sort_values(\n",
    "  by = [\n",
    "    \"netAssets.raw\",\n",
    "    \"netExpenseRatio.raw\",\n",
    "    \"firstTradeDateMilliseconds\",\n",
    "    \"longName\",\n",
    "    \"symbol\"\n",
    "  ],\n",
    "  ascending = [False, True, True, True, True],\n",
    "  kind = \"stable\"\n",
    ")\n",
    "tickers = sorted_df.loc[~sorted_df[\"netAssets.raw\"].duplicated(), \"symbol\"].tolist()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "fb8dc9ba",
   "metadata": {},
   "outputs": [],
   "source": [
    "allocations = [\"IVV\", \"IDEV\", \"IUSB\", \"IEMG\", \"IJH\", \"IAGG\", \"IJR\"]\n",
    "tickers = tickers + allocations"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f2234dd",
   "metadata": {},
   "source": [
    "# Optimization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "2af33a48",
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "import cvxpy as cp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "5a4e07bb",
   "metadata": {},
   "outputs": [],
   "source": [
    "def min_rss_optim(x, y):\n",
    "    \n",
    "  w = cp.Variable(x.shape[1])\n",
    "    \n",
    "  objective = cp.Minimize(cp.sum_squares(y - x @ w))\n",
    "    \n",
    "  constraints = [cp.sum(w) == 1, w >= 0, w <= 1]\n",
    "    \n",
    "  problem = cp.Problem(objective, constraints)\n",
    "  problem.solve()\n",
    "    \n",
    "  return w.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "6dba85bc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pause one second after five requests\n"
     ]
    }
   ],
   "source": [
    "#| echo: false\n",
    "#| output: false # pause one second after five requests\n",
    "# exec(open(\"posts/helper-prices.py\").read()) # local\n",
    "exec(open(\"../helper-prices.py\").read()) # run then render\n",
    "\n",
    "overlap_df = returns_df.rolling(scale[\"overlap\"], min_periods = 1).mean()\n",
    "\n",
    "# overlap_df = overlap_df.dropna()\n",
    "# overlap_x_df = overlap_df[factors]\n",
    "overlap_x_df = overlap_df[allocations]\n",
    "# overlap_y_df = overlap_df.loc[:, ~overlap_df.columns.isin(factors + allocations)]\n",
    "overlap_y_df = overlap_df.loc[:, ~overlap_df.columns.isin(allocations)]\n",
    "# overlap_z_df = overlap_df[allocations]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "e0ba14d3",
   "metadata": {},
   "outputs": [],
   "source": [
    "def pnl(x):\n",
    "  return np.nanprod(1 + x) - 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "33a1c689",
   "metadata": {},
   "outputs": [],
   "source": [
    "performance_df = returns_df.rolling(width, min_periods = 1).apply(pnl, raw = False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "e9a218f2",
   "metadata": {},
   "outputs": [],
   "source": [
    "n_rows = overlap_df.shape[0]\n",
    "result_ls = []\n",
    "index_ls = []\n",
    "\n",
    "# for i in range(width - 1, n_rows):\n",
    "for i in range(n_rows - 1, n_rows):\n",
    "  \n",
    "  idx = range(max(i - width + 1, 0), i + 1)\n",
    "  x_subset = overlap_x_df.iloc[idx]\n",
    "  y_subset = overlap_y_df.iloc[idx]\n",
    "  params_ls = []\n",
    "  tickers_ls = []\n",
    "  performance_ls = []\n",
    "  \n",
    "  for j in [ticker for ticker in tickers if ticker not in allocations]:\n",
    "    \n",
    "    idx = ~x_subset.isna().any(axis = 1) & ~y_subset[j].isna()\n",
    "    x_complete = x_subset.loc[idx]\n",
    "    y_complete = y_subset.loc[idx, j]\n",
    "    \n",
    "    if (x_complete.shape[0] > 0) and (y_complete.size > 0):\n",
    "        \n",
    "      params = min_rss_optim(x_complete.values, y_complete.values)\n",
    "      params_ls.append(params)\n",
    "      \n",
    "      tickers_ls.append(j)\n",
    "      \n",
    "      performance_ls.append(performance_df[j].iloc[i])\n",
    "\n",
    "  if params_ls:\n",
    "    \n",
    "    result = pd.DataFrame(params_ls, index = tickers_ls)\n",
    "    result[\"performance\"] = performance_ls\n",
    "    \n",
    "    result_ls.append(result)\n",
    "    index_ls.append(overlap_x_df.index[i])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "c761c0f0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# json.dump([x.to_dict() for x in result_ls], open(\"result_ls.json\", \"w\"))\n",
    "# json.dump([x.isoformat() for x in index_ls], open(\"index_ls.json\", \"w\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "33e8ac95",
   "metadata": {},
   "source": [
    "# Performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "5c661853",
   "metadata": {},
   "outputs": [],
   "source": [
    "# result_ls = [pd.DataFrame(x) for x in json.load(open(\"result_ls.json\", \"r\"))]\n",
    "# index_ls = [pd.Timestamp(x) for x in json.load(open(\"index_ls.json\", \"r\"))]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "d2467701",
   "metadata": {},
   "outputs": [],
   "source": [
    "def quantile_cut(x):\n",
    "  \n",
    "  result = pd.cut(\n",
    "    -x,\n",
    "    bins = np.nanquantile(-x, [0, 0.25, 0.5, 0.75, 1]),\n",
    "    labels = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"],\n",
    "    include_lowest = True\n",
    "  )\n",
    "  \n",
    "  return result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "82a2f0e7",
   "metadata": {},
   "outputs": [],
   "source": [
    "n_rows = len(result_ls)\n",
    "numeric_cols = allocations + [\"performance\"]\n",
    "score_ls = []\n",
    "\n",
    "for i in range(n_rows):\n",
    "  \n",
    "  score_df = pd.DataFrame(result_ls[i])\n",
    "  score_df.columns = numeric_cols\n",
    "  \n",
    "  score_df[\"date\"] = index_ls[i]\n",
    "  score_df[\"quantile\"] = quantile_cut(score_df[\"performance\"])\n",
    "\n",
    "  score = score_df.groupby([\"date\", \"quantile\"], observed = True)[numeric_cols] \\\n",
    "    .mean() \\\n",
    "    .reset_index()\n",
    "\n",
    "  overall_means = score_df[numeric_cols].mean()\n",
    "  \n",
    "  overall = pd.DataFrame({\n",
    "    \"date\": [index_ls[i]],\n",
    "    \"quantile\": [\"Overall\"],\n",
    "    **{col: [overall_means[col]] for col in numeric_cols}\n",
    "  })\n",
    "  \n",
    "  score = pd.concat([score, overall], ignore_index = True)\n",
    "  \n",
    "  score_ls.append(score)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "ff41deb6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "        date quantile       IVV      IDEV      IUSB      IEMG       IJH  \\\n",
      "0 2025-12-12       Q1  0.400167  0.134559  0.096774  0.045438  0.084075   \n",
      "1 2025-12-12       Q2  0.316834  0.104681  0.180371  0.056573  0.070196   \n",
      "2 2025-12-12       Q3  0.259074  0.080563  0.206378  0.051208  0.025888   \n",
      "3 2025-12-12       Q4  0.142944  0.095665  0.212472  0.080258  0.014413   \n",
      "4 2025-12-12  Overall  0.281241  0.104246  0.173045  0.058210  0.049080   \n",
      "\n",
      "       IAGG       IJR  performance  \n",
      "0  0.203887  0.035100     0.243383  \n",
      "1  0.207304  0.064041     0.144663  \n",
      "2  0.306827  0.070062     0.101470  \n",
      "3  0.369341  0.084907     0.039914  \n",
      "4  0.271001  0.063177     0.133728  \n"
     ]
    }
   ],
   "source": [
    "score_df = pd.concat(score_ls, ignore_index = True)\n",
    "print(score_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "1a5a3f30",
   "metadata": {},
   "outputs": [],
   "source": [
    "# score_df.to_json(\"score_df.json\", date_format = \"iso\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3",
   "path": "C:\\Users\\jason\\AppData\\Local\\Programs\\Python\\Python310\\share\\jupyter\\kernels\\python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
