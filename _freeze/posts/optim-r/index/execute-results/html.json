{
  "hash": "999219de5ebc03bbe30ec1d04c7449b5",
  "result": {
    "markdown": "---\ntitle: \"Optimization\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - r\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(quantmod)\nlibrary(roll)\nlibrary(data.table)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_r <- c(\"SP500\", \"DTWEXAFEGS\") # \"SP500\" does not contain dividends; note: \"DTWEXM\" discontinued as of Jan 2020\nfactors_d <- c(\"DGS10\", \"BAMLH0A0HYM2\")\nfactors <- c(factors_r, factors_d)\nwidth <- 252\nscale <- list(\"periods\" = 252, \"overlap\" = 5)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngetSymbols(factors, src = \"FRED\")\nlevels_xts <- do.call(merge, c(lapply(factors, function(i) get(i)), all = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns_xts <- do.call(merge, lapply(factors, function(i) {\n    if (i %in% factors_r) {\n        diff(log((levels_xts[ , i])))\n    } else if (i %in% factors_d) {\n        -diff(levels_xts[ , i]) / 100\n    }    \n}))\noverlap_xts <- roll_mean(returns_xts, scale[[\"overlap\"]], min_obs = 1, na_restore = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(CVXR)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntickers <- \"BAICX\" # fund inception date is \"2011-11-28\" \ninvisible(getSymbols(tickers, src = \"tiingo\", api.key = Sys.getenv(\"TIINGO_API_KEY\"), adjust = TRUE))\nprices_xts <- do.call(merge, c(lapply(tickers, function(i) Cl(get(i))), all = TRUE))\ncolnames(prices_xts) <- tickers\nindex(prices_xts) <- as.Date(index(prices_xts))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns_xts <- merge(returns_xts, diff(log(prices_xts)))\noverlap_xts <- merge(overlap_xts, roll_mean(returns_xts[ , tickers], scale[[\"overlap\"]], min_obs = 1))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# weights <- 0.9 ^ ((width - 1):0)\nweights <- rep(1, width)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noverlap_xts <- na.omit(overlap_xts)\noverlap_x_xts <- tail(overlap_xts[ , factors], width) # same dimension as `weights`\noverlap_y_xts <- tail(overlap_xts[ , tickers], width)\n```\n:::\n\n\n# Random weights\n\nNeed to generate uniformly distributed weights $\\mathbf{w}=(w_{1},w_{2},\\ldots,w_{N})$ such that $\\sum_{j=1}^{N}w_{i}=1$ and $w_{i}\\geq0$:\n\n-   **Approach 1**: tempting to use $w_{i}=\\frac{u_{i}}{\\sum_{j=1}^{N}u_{i}}$ where $u_{i}\\sim U(0,1)$ but the distribution of $\\mathbf{w}$ is not uniform\n\n-   **Approach 2**: instead, generate $\\text{Exp}(1)$ and then normalize\n\nCan also scale random weights by $M$, e.g. if sum of weights must be 10% then multiply weights by 10%.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrand_weights1 <- function(n_sim, n_assets) {\n    \n    rand_exp <- matrix(runif(n_sim * n_assets), nrow = n_sim, ncol = n_assets)\n    result <- rand_exp / rowSums(rand_exp)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_assets <- 3\nn_sim <- 10000\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napproach1 <- rand_weights1(n_sim, n_assets)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=384}\n:::\n:::\n\n\n**Approach 2**: uniform sample from the simplex (<http://mathoverflow.net/a/76258>) and then normalize\n\n-   If $z\\sim U(0,1)$ then $-\\ln(z)$ is an $\\text{Exp}(1)$ distribution\n\nThis is also known as generating a random vector from the symmetric Dirichlet distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrand_weights2 <- function(n_sim, n_assets, lmbda) {\n    \n    # uses 'inverse transform sampling' method: <https://en.wikipedia.org/wiki/Inverse_transform_sampling>\n    rand_exp <- matrix(-log(1 - runif(n_sim * n_assets)) / lmbda, nrow = n_sim, ncol = n_assets)\n    result <- rand_exp / rowSums(rand_exp)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlmbda <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napproach2 <- rand_weights2(n_sim, n_assets, lmbda)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=384}\n:::\n:::\n\n\n**Approach 3**: directly generate $\\text{Exp}(1)$ and then normalize\n\n-   If $x\\sim\\text{Exp}(1)$ then let $y_{i}=\\frac{x_{i}}{\\sum_{i=1}^{N}x_{i}}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrand_weights3 <- function(n_sim, n_assets) {\n    \n    rand_exp <- matrix(rexp(n_sim * n_assets), nrow = n_sim, ncol = n_assets)\n    result <- rand_exp / rowSums(rand_exp)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napproach3 <- rand_weights3(n_sim, n_assets)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=384}\n:::\n:::\n\n\n## Random turnover\n\nHow to generate random weights between lower bound $a$ and upper bound $b$ that sum to zero?\n\n-   **Approach 1**: tempting to multiply random weights by $M$ and then subtract by $\\frac{M}{N}$ but the distribution is not between $a$ and $b$\n\n-   **Approach 2**: instead, use an iterative approach for random turnover:\n\n    1.  Generate $N-1$ uniformly distributed weights between $a$ and $b$\n    2.  For $u_{N}$ compute sum of values and subtract from $M$\n    3.  If $u_{N}$ is between $a$ and $b$, then keep; otherwise, discard\n\nThen add random turnover to previous period's random weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrand_iterative <- function(n_assets, lower, upper, target) {\n    \n    plug <- FALSE\n    \n    while (!plug) {\n        \n        result <- as.matrix(runif(n_assets - 1, min = lower, max = upper))\n        temp <- target - sum(result)\n        \n        if ((temp <= upper) && (temp >= lower)) {\n            plug <- TRUE            \n        }\n        \n    }\n    \n    result <- append(result, temp)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrand_turnover1 <- function(n_sim, n_assets, lower, upper, target) {\n    \n    rng <- upper - lower\n    \n    result <- rand_weights3(n_sim, n_assets) * rng\n    result <- result - rng / n_assets\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrand_turnover2 <- function(n_sim, n_assets, lower, upper, target) {\n    \n    result <- matrix(rand_iterative(n_assets, lower, upper, target), nrow = 1, ncol = n_assets)\n    \n    while (nrow(result) < n_sim) {\n        \n        temp <- matrix(rand_iterative(n_assets, lower, upper, target), nrow = 1, ncol = n_assets)\n        result <- rbind(result, temp)\n        \n    }\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlower <- -0.05\nupper <- 0.05\ntarget <- 0\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napproach1 <- rand_turnover1(n_sim, n_assets, lower, upper, target)\napproach2 <- rand_turnover2(n_sim, n_assets, lower, upper, target)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=384}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=384}\n:::\n:::\n\n\n# Mean-variance\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeometric_mean <- function(x, scale) {\n    \n    result <- prod(1 + x) ^ (scale / length(x)) - 1\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns_x_xts <- na.omit(returns_xts)[ , factors] # extended history # REMOVE LATER\nmu <- apply(returns_x_xts, 2, geometric_mean, scale = scale[[\"periods\"]])\nsigma <- cov(overlap_x_xts) * scale[[\"periods\"]] * scale[[\"overlap\"]]\n```\n:::\n\n\n## Maximize mean\n\n$$\n\\begin{aligned}\n\\begin{array}{rrcl}\n\\displaystyle\\max_{x}&\\mu^{T}\\mathbf{w}\\\\\n\\textrm{s.t.}&\\mathbf{w}^T\\Sigma\\mathbf{w}&\\leq&\\sigma^{2}\\\\\n&e^T\\mathbf{w}&=&1\n\\end{array}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntarget <- 0.06\n```\n:::\n\n\n-   <https://palomar.home.ece.ust.hk/MAFS6010R_lectures/slides_robust_portfolio.html>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_pnl_optim <- function(mu, sigma, target) {\n    \n    params <- Variable(length(mu))\n    \n    cons <- list(params >= 0, sum(params) == 1,\n                 quad_form(params, sigma) <= target ^ 2)\n    \n    obj <- Maximize(t(params) %*% mu)\n        \n    result <- solve(Problem(obj, cons))$getValue(params)\n    \n    return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparams1 <- max_pnl_optim(mu, sigma, target)\nparams1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             [,1]\n[1,] 4.587378e-01\n[2,] 5.412619e-01\n[3,] 1.406586e-07\n[4,] 8.392967e-08\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmu %*% params1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n[1,] 0.04181331\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(t(params1) %*% sigma %*% params1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,] 0.06\n```\n:::\n:::\n\n\n## Minimize variance\n\n$$\n\\begin{aligned}\n\\begin{array}{rrcl}\n\\displaystyle\\min_{x}&\\mathbf{w}^T\\Sigma\\mathbf{w}\\\\\n\\textrm{s.t.}&\\mu^{T}\\mathbf{w}&\\geq&M\\\\\n&e^T\\mathbf{w}&=&1\n\\end{array}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntarget <- 0.03\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_risk_optim <- function(mu, sigma, target) {\n    \n    params <- Variable(length(mu))\n    \n    cons <- list(params >= 0, sum(params) == 1,\n                 sum(mu * params) >= target)\n    \n    obj <- Minimize(quad_form(params, sigma))\n        \n    result <- solve(Problem(obj, cons))$getValue(params)\n    \n    return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparams2 <- min_risk_optim(mu, sigma, target)\nparams2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             [,1]\n[1,] 3.084858e-01\n[2,] 5.005733e-01\n[3,] 1.909410e-01\n[4,] 2.115583e-21\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmu %*% params2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,] 0.03\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(t(params2) %*% sigma %*% params2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n[1,] 0.04214223\n```\n:::\n:::\n\n\n## Maximize utility\n\n$$\n\\begin{aligned}\n\\begin{array}{rrcl}\n\\displaystyle\\max_{x}&\\mu^{T}\\mathbf{w}-\\frac{1}{2}\\delta(\\mathbf{w}^T\\Sigma\\mathbf{w})\\\\\n\\textrm{s.t.}&e^T\\mathbf{w}&=&1\n\\end{array}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nir <- 0.5\ntarget <- ir / 0.06 # ir / std (see Black-Litterman)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_ratio_optim <- function(mu, sigma, target) {\n    \n    params <- Variable(length(mu))\n    \n    cons <- list(params >= 0, sum(params) == 1)\n    \n    obj <- Maximize(t(mu) %*% params - 0.5 * target * quad_form(params, sigma))\n        \n    result <- solve(Problem(obj, cons))$getValue(params)\n    \n    return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparams3 <- max_ratio_optim(mu, sigma, target)\nparams3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             [,1]\n[1,] 4.784496e-01\n[2,] 5.215504e-01\n[3,] 1.816669e-22\n[4,] 1.222268e-22\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmu %*% params3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]\n[1,] 0.04300942\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(t(params3) %*% sigma %*% params3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          [,1]\n[1,] 0.0622523\n```\n:::\n:::\n\n\n## Minimize residual sum of squares\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\"max_pnl\" = params1,\n           \"min_risk\" = params2,\n           \"max_ratio\" = params3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       max_pnl     min_risk    max_ratio\n1 4.587378e-01 3.084858e-01 4.784496e-01\n2 5.412619e-01 5.005733e-01 5.215504e-01\n3 1.406586e-07 1.909410e-01 1.816669e-22\n4 8.392967e-08 2.115583e-21 1.222268e-22\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}