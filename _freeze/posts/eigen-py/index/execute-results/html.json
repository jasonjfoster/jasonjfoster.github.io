{
  "hash": "8264567565f40e82d5d65f62f5634fe4",
  "result": {
    "markdown": "---\ntitle: \"Eigen\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - python\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nimport pandas_datareader as pdr\nfrom scipy.stats import norm, chi2\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfactors_r = [\"SP500\", \"DTWEXAFEGS\"] # \"SP500\" does not contain dividends; note: \"DTWEXM\" discontinued as of Jan 2020\nfactors_d = [\"DGS10\", \"BAMLH0A0HYM2\"]\nfactors = factors_r + factors_d\nwidth = 252\nscale = {\"periods\": 252, \"overlap\": 5}\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n-   <https://pandas-datareader.readthedocs.io/en/latest/remote_data.html>\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlevels_df = pdr.get_data_fred(factors, start = \"1900-01-01\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nreturns_df = levels_df.apply(lambda x: np.log(x).diff() if x.name in factors_r else -x.diff() / 100)\noverlap_df = returns_df.rolling(scale[\"overlap\"], min_periods = 1).mean()\nreturns_df = pd.concat([returns_df, overlap_df], keys = [\"returns\", \"overlap\"], axis = 1)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\n```\n:::\n\n\n-   Open: <https://github.com/pydata/pandas-datareader/issues/965>\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntickers = [\"BAICX\"] # fund inception date is \"2011-11-28\"\nprices_df = pdr.get_data_tiingo(tickers, start = \"1900-01-01\", api_key = os.getenv(\"TIINGO_API_KEY\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nC:\\Users\\jason\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\pandas_datareader\\tiingo.py:234: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only\n  return pd.concat(dfs, self._concat_axis)\n```\n:::\n\n```{.python .cell-code}\nprices_df = prices_df.pivot_table(index = \"date\", columns = \"symbol\", values = \"adjClose\") \\\n    .tz_localize(None)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nreturns_cols = list(zip([\"returns\"], tickers))\noverlap_cols = list(zip([\"overlap\"], tickers))\nreturns_df[returns_cols] = np.log(prices_df).diff()\nreturns_df[overlap_cols] = returns_df[returns_cols].rolling(scale[\"overlap\"], min_periods = 1).mean()\nreturns_df.sort_index(axis = 1, inplace = True)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# weights = np.array([0.9 ** i for i in range(width - 1, -1, -1)]).reshape((width, 1))\nweights = np.array([1] * width).reshape((width, 1))\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\noverlap_x_df = returns_df.dropna()[\"overlap\"][factors]\noverlap_y_df = returns_df.dropna()[\"overlap\"][tickers]\noverlap_x_mat = np.matrix(overlap_x_df[-width:])\noverlap_y_mat = np.matrix(overlap_y_df[-width:])\n```\n:::\n\n\n# Eigenanalysis\n\nUnderlying returns are structural bets that can be analyzed through dimension reduction techniques such as principal components analysis (PCA). Most empirical studies apply PCA to a covariance matrix (*note: for multi-asset portfolios, use the correlation matrix because asset-class variances are on different scales*) of equity returns (yield changes) and find that movements in the equity markets (yield curve) can be explained by a subset of principal components. For example, the yield curve can be decomposed in terms of shift, twist, and butterfly, respectively.\n\n## Eigendecomposition\n\n$$\n\\begin{aligned}\n\\boldsymbol{\\Sigma}&=\\lambda_{1}\\mathbf{v}_{1}\\mathbf{v}_{1}^\\mathrm{T}+\\lambda_{2}\\mathbf{v}_{2}\\mathbf{v}_{2}^\\mathrm{T}+\\cdots+\\lambda_{k}\\mathbf{v}_{k}\\mathbf{v}_{k}^\\mathrm{T}\\\\\n&=V\\Lambda V^{\\mathrm{T}}\n\\end{aligned}\n$$\n\n-   <https://www.r-bloggers.com/fixing-non-positive-definite-correlation-matrices-using-r-2/>\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef eigen_decomp(x, comps):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    L = L[idx]\n    V = V[:, idx]\n        \n    L = L[:comps]\n    V = V[:, :comps]\n    \n    result = np.matmul(V, np.multiply(L, V.T))\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncomps = 1\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\neigen_decomp(overlap_x_mat, comps) * scale[\"periods\"] * scale[\"overlap\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([[ 1.94794750e-02, -3.81257865e-03,  3.95746280e-04,\n         1.41506503e-03],\n       [-3.81257865e-03,  7.46208817e-04, -7.74565956e-05,\n        -2.76960581e-04],\n       [ 3.95746280e-04, -7.74565956e-05,  8.04000712e-06,\n         2.87485530e-05],\n       [ 1.41506503e-03, -2.76960581e-04,  2.87485530e-05,\n         1.02795842e-04]])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# np.cov(overlap_x_mat.T) * scale[\"periods\"] * scale[\"overlap\"]\n```\n:::\n\n\n## Variance explained\n\nWe often look at the proportion of variance explained by the first $i$ principal components as an indication of how many components are needed.\n\n$$\n\\begin{aligned}\n\\frac{\\sum_{j=1}^{i}{\\lambda_{j}}}{\\sum_{j=1}^{k}{\\lambda_{j}}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef variance_explained(x):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))   \n    idx = L.argsort()[::-1]\n    L = L[idx]\n    \n    result = L.cumsum() / L.sum()\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nvariance_explained(overlap_x_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.85663169, 0.98971785, 0.99658121, 1.        ])\n```\n:::\n:::\n\n\n## Cosine similarity\n\nAlso, a challenge of rolling PCA is to try to match the eigenvectors: may need to change the sign and order.\n\n$$\n\\begin{aligned}\n\\text{similarity}=\\frac{\\mathbf{A}\\cdot\\mathbf{B}}{\\|\\mathbf{A}\\|\\|\\mathbf{B}\\|}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef eigen_vals(x):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    L = L[idx]\n    \n    return pd.DataFrame(L)\n\ndef eigen_vecs(x):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    V = V[:, idx]\n    \n    return pd.DataFrame(V)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef roll_eigen1(x, width, comp):\n    \n    n_rows = len(x)\n    result = pd.DataFrame()\n    \n    for i in range(width - 1, n_rows):\n        \n        idx = range(max(i - width + 1, 0), i + 1)\n        evec = eigen_vecs(x.iloc[idx]).iloc[:, comp - 1]\n        result = result.append(evec.transpose())\n    \n    result.index = x.index[(width - 1):]\n    result.columns = x.columns\n    \n    return result  \n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncomp = 1\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nraw_df = roll_eigen1(overlap_x_df, width, comp)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=576}\n:::\n:::\n\n\n-   <https://quant.stackexchange.com/a/3095>\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef roll_eigen2(x, width, comp):\n    \n    n_rows = len(x)\n    result = pd.DataFrame()\n    \n    for i in range(width - 1, n_rows):\n        \n        idx = range(max(i - width + 1, 0), i + 1)\n        evec = eigen_vecs(x.iloc[idx]).iloc[:, comp - 1]\n        \n        if i > width - 1:\n            \n            similarity = np.matmul(np.matrix(evec),\n                                   np.matrix(result.iloc[-1, :]).T)\n            evec = pd.DataFrame(np.multiply(np.sign(similarity), np.matrix(evec))) \n            result = result.append(evec)\n            \n        else:\n            result = result.append(evec.transpose())\n    \n    result.index = x.index[(width - 1):]\n    result.columns = x.columns\n    \n    return result  \n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nclean_df = roll_eigen2(overlap_x_df, width, comp)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=576}\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}