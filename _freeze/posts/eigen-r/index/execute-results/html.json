{
  "hash": "00b22fd337acd239dfbec246c1b410fe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Eigen\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - r\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_r <- c(\"SP500\", \"DTWEXAFEGS\") # \"SP500\" does not contain dividends; note: \"DTWEXM\" discontinued as of Jan 2020\nfactors_d <- c(\"DGS10\", \"BAMLH0A0HYM2\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n# Decomposition\n\nUnderlying returns are structural bets that can be analyzed through dimension reduction techniques such as principal components analysis (PCA). Most empirical studies apply PCA to a covariance matrix (*note: for multi-asset portfolios, use the correlation matrix because asset-class variances are on different scales*) of equity returns (yield changes) and find that movements in the equity markets (yield curve) can be explained by a subset of principal components. For example, the yield curve can be decomposed in terms of shift, twist, and butterfly, respectively.\n\n$$\n\\begin{aligned}\n\\boldsymbol{\\Sigma}&=\\lambda_{1}\\mathbf{v}_{1}\\mathbf{v}_{1}^\\mathrm{T}+\\lambda_{2}\\mathbf{v}_{2}\\mathbf{v}_{2}^\\mathrm{T}+\\cdots+\\lambda_{k}\\mathbf{v}_{k}\\mathbf{v}_{k}^\\mathrm{T}\\\\\n&=V\\Lambda V^{\\mathrm{T}}\n\\end{aligned}\n$$\n\n-   <https://www.r-bloggers.com/fixing-non-positive-definite-correlation-matrices-using-r-2/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\neigen_decomp <- function(x, comps) {\n    \n    LV <- eigen(cov(x))\n    L <- LV[[\"values\"]][1:comps]\n    V <- LV[[\"vectors\"]][ , 1:comps]\n    \n    result <- V %*% sweep(t(V), 1, L, \"*\")\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncomps <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neigen_decomp(overlap_xts, comps) * scale[[\"periods\"]] * scale[[\"overlap\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              [,1]          [,2]          [,3]          [,4]\n[1,]  3.015880e-02 -3.972512e-03 -8.686004e-05  2.500534e-03\n[2,] -3.972512e-03  5.232585e-04  1.144119e-05 -3.293698e-04\n[3,] -8.686004e-05  1.144119e-05  2.501647e-07 -7.201760e-06\n[4,]  2.500534e-03 -3.293698e-04 -7.201760e-06  2.073248e-04\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# cov(overlap_xts) * scale[[\"periods\"]] * scale[[\"overlap\"]]\n```\n:::\n\n\n# Variance\n\nWe often look at the proportion of variance explained by the first $i$ principal components as an indication of how many components are needed.\n\n$$\n\\begin{aligned}\n\\frac{\\sum_{j=1}^{i}{\\lambda_{j}}}{\\sum_{j=1}^{k}{\\lambda_{j}}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariance_explained <- function(x) {\n    \n    LV <- eigen(cov(x))\n    L <- LV[[\"values\"]]\n    \n    result <- cumsum(L) / sum(L)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvariance_explained(overlap_xts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8785010 0.9920858 0.9982238 1.0000000\n```\n\n\n:::\n:::\n\n\n# Similarity\n\nAlso, a challenge of rolling PCA is to try to match the eigenvectors: may need to change the sign and order.\n\n$$\n\\begin{aligned}\n\\text{similarity}=\\frac{\\mathbf{v}_{t}\\cdot\\mathbf{v}_{t-1}}{\\|\\mathbf{v}_{t}\\|\\|\\mathbf{v}_{t-1}\\|}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimilarity <- function(V, V0) {\n    \n    n_cols_v <- ncol(V)\n    n_cols_v0 <- ncol(V0)\n    result <- matrix(0, nrow = n_cols_v, ncol = n_cols_v0)\n    \n    for (i in 1:n_cols_v) {\n      for (j in 1:n_cols_v0) {\n        result[i, j] <- crossprod(V[ , i], V0[ , j]) /\n            sqrt(crossprod(V[ , i]) * crossprod(V0[ , j]))\n      }\n    }\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nroll_eigen1 <- function(x, width, comp) {\n    \n    n_rows <- nrow(x)\n    result_ls <- list()\n    \n    for (i in width:n_rows) {\n        \n        idx <- max(i - width + 1, 1):i\n        \n        LV <- eigen(cov(x[idx, ]))\n        V <- LV[[\"vectors\"]]\n        \n        result_ls <- append(result_ls, list(V[ , comp]))\n        \n    }\n    \n    result <- do.call(rbind, result_ls)\n    result <- xts(result, index(x)[width:n_rows])\n    colnames(result) <- colnames(x)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_df <- roll_eigen1(overlap_xts, width, comp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# # install.packages(\"devtools\")\n# devtools::install_github(\"jasonjfoster/rolleigen\") # roll (>= 1.1.7)\n# library(rolleigen)\n# raw_df <- roll_eigen(overlap_xts, width, order = TRUE)[[\"vectors\"]][ , comp, ]\n# raw_df <- xts(t(raw_df), index(overlap_xts))\n# colnames(raw_df) <- colnames(overlap_xts)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\n\n-   <https://quant.stackexchange.com/a/3095>\n-   <https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4400158>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroll_eigen2 <- function(x, width, comp) {\n    \n    n_rows <- nrow(x)\n    V_ls <- list()\n    result_ls <- list()\n    \n    for (i in width:n_rows) {\n        \n        idx <- max(i - width + 1, 1):i\n        \n        LV <- eigen(cov(x[idx, ]))\n        V <- LV[[\"vectors\"]]\n                \n        if (i > width) {\n          \n            # cosine <- crossprod(V, V_ls[[length(V_ls)]])\n            cosine <- similarity(V, V_ls[[length(V_ls)]])\n            order <- apply(abs(cosine), 1, which.max)\n            V <- t(sign(diag(cosine[ , order])) * t(V[ , order]))\n            \n        }\n        \n        V_ls <- append(V_ls, list(V))\n        result_ls <- append(result_ls, list(V[ , comp]))\n                \n    }\n    \n    result <- do.call(rbind, result_ls)\n    result <- xts(result, index(x)[width:n_rows])\n    colnames(result) <- colnames(x)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_df <- roll_eigen2(overlap_xts, width, comp)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=576}\n:::\n:::\n\n\n# Implied shocks\n\nProduct of the $n$th eigenvector and square root of the $n$th eigenvalue:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroll_shocks <- function(x, width, comp) {\n  \n    n_rows <- nrow(x)\n    V_ls <- list()\n    result_ls <- list()\n    \n    for (i in width:n_rows) {\n        \n        idx <- max(i - width + 1, 1):i\n        \n        LV <- eigen(cov(x[idx, ]))\n        L <- LV[[\"values\"]]\n        V <- LV[[\"vectors\"]]\n        \n        if (length(V_ls) > 1) {\n          \n            # cosine <- crossprod(V, V_ls[[length(V_ls)]])\n            cosine <- similarity(V, V_ls[[length(V_ls)]])\n            order <- apply(abs(cosine), 1, which.max)\n            L <- L[order]\n            V <- t(sign(diag(cosine[ , order])) * t(V[ , order]))\n          \n        }\n        \n        shocks <- sqrt(L[comp]) * V[ , comp]\n        V_ls <- append(V_ls, list(V))\n        result_ls <- append(result_ls, list(shocks))\n                \n    }\n    \n    result <- do.call(rbind, result_ls)\n    result <- xts(result, index(x)[width:n_rows])\n    colnames(result) <- colnames(x)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshocks_xts <- roll_shocks(overlap_xts, width, comp) * sqrt(scale[[\"periods\"]] * scale[[\"overlap\"]])\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=576}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}