{
  "hash": "d1dbd9bfe61ca67e80ccd5808b03b93f",
  "result": {
    "markdown": "---\ntitle: \"Eigen\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - r\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(quantmod)\nlibrary(roll)\nlibrary(data.table)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_r <- c(\"SP500\", \"DTWEXAFEGS\") # \"SP500\" does not contain dividends; note: \"DTWEXM\" discontinued as of Jan 2020\nfactors_d <- c(\"DGS10\", \"BAMLH0A0HYM2\")\nfactors <- c(factors_r, factors_d)\nwidth <- 252\nscale <- list(\"periods\" = 252, \"overlap\" = 5)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngetSymbols(factors, src = \"FRED\")\nlevels_xts <- do.call(merge, c(lapply(factors, function(i) get(i)), all = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns_xts <- do.call(merge, lapply(factors, function(i) {\n    if (i %in% factors_r) {\n        diff(log((levels_xts[ , i])))\n    } else if (i %in% factors_d) {\n        -diff(levels_xts[ , i]) / 100\n    }    \n}))\noverlap_xts <- roll_mean(returns_xts, scale[[\"overlap\"]], min_obs = 1, na_restore = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntickers <- \"BAICX\" # fund inception date is \"2011-11-28\" \ninvisible(getSymbols(tickers, src = \"tiingo\", api.key = Sys.getenv(\"TIINGO_API_KEY\"), adjust = TRUE))\nprices_xts <- do.call(merge, c(lapply(tickers, function(i) Cl(get(i))), all = TRUE))\ncolnames(prices_xts) <- tickers\nindex(prices_xts) <- as.Date(index(prices_xts))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns_xts <- merge(returns_xts, diff(log(prices_xts)))\noverlap_xts <- merge(overlap_xts, roll_mean(returns_xts[ , tickers], scale[[\"overlap\"]], min_obs = 1))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# weights <- 0.9 ^ ((width - 1):0)\nweights <- rep(1, width)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# overlap_df <- na.omit(overlap_xts)\noverlap_x_df <- na.omit(overlap_xts)[ , factors]\noverlap_y_df <- na.omit(overlap_xts)[ , tickers]\noverlap_x_xts <- tail(overlap_x_df, width)\noverlap_y_xts <- tail(overlap_y_df, width)\n```\n:::\n\n\n# Eigenanalysis\n\nUnderlying returns are structural bets that can be analyzed through dimension reduction techniques such as principal components analysis (PCA). Most empirical studies apply PCA to a covariance matrix (*note: for multi-asset portfolios, use the correlation matrix because asset-class variances are on different scales*) of equity returns (yield changes) and find that movements in the equity markets (yield curve) can be explained by a subset of principal components. For example, the yield curve can be decomposed in terms of shift, twist, and butterfly, respectively.\n\n## Eigendecomposition\n\n$$\n\\begin{aligned}\n\\boldsymbol{\\Sigma}&=\\lambda_{1}\\mathbf{v}_{1}\\mathbf{v}_{1}^\\mathrm{T}+\\lambda_{2}\\mathbf{v}_{2}\\mathbf{v}_{2}^\\mathrm{T}+\\cdots+\\lambda_{k}\\mathbf{v}_{k}\\mathbf{v}_{k}^\\mathrm{T}\\\\\n&=V\\Lambda V^{\\mathrm{T}}\n\\end{aligned}\n$$\n\n-   <https://www.r-bloggers.com/fixing-non-positive-definite-correlation-matrices-using-r-2/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\neigen_decomp <- function(x, comps) {\n    \n    LV <- eigen(cov(x))\n    L <- LV$values[1:comps]\n    V <- LV$vectors[ , 1:comps]\n    \n    result <- V %*% sweep(t(V), 1, L, \"*\")\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncomps <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neigen_decomp(overlap_x_xts, comps) * scale[[\"periods\"]] * scale[[\"overlap\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              [,1]          [,2]          [,3]          [,4]\n[1,]  0.0194794750 -0.0038125787  3.957463e-04  1.415065e-03\n[2,] -0.0038125787  0.0007462088 -7.745660e-05 -2.769606e-04\n[3,]  0.0003957463 -0.0000774566  8.040007e-06  2.874855e-05\n[4,]  0.0014150650 -0.0002769606  2.874855e-05  1.027958e-04\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# cov(overlap_x_xts) * scale[[\"periods\"]] * scale[[\"overlap\"]]\n```\n:::\n\n\n## Variance explained\n\nWe often look at the proportion of variance explained by the first $i$ principal components as an indication of how many components are needed.\n\n$$\n\\begin{aligned}\n\\frac{\\sum_{j=1}^{i}{\\lambda_{j}}}{\\sum_{j=1}^{k}{\\lambda_{j}}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariance_explained <- function(x) {\n    \n    LV <- eigen(cov(x))\n    L <- LV$values\n    \n    result <- cumsum(L) / sum(L)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvariance_explained(overlap_x_xts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8566317 0.9897178 0.9965812 1.0000000\n```\n:::\n:::\n\n\n## Cosine similarity\n\nAlso, a challenge of rolling PCA is to try to match the eigenvectors: may need to change the sign and order.\n\n$$\n\\begin{aligned}\n\\text{similarity}=\\frac{\\mathbf{A}\\cdot\\mathbf{B}}{\\|\\mathbf{A}\\|\\|\\mathbf{B}\\|}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\neigen_vals <- function(x) {\n    \n    LV <- eigen(cov(x))\n    L <- LV$values\n    \n    return(L)    \n}\n\neigen_vecs <- function(x) {\n    \n    LV <- eigen(cov(x))\n    V <- LV$vectors\n    \n    return(V)    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nroll_eigen1 <- function(x, width, comp) {\n    \n    n_rows <- nrow(x)\n    result_ls <- list()\n    \n    for (i in width:n_rows) {\n        \n        idx <- max(i - width + 1, 1):i\n        evec <- eigen_vecs(x[idx, ])[ , comp]\n        result_ls <- append(result_ls, list(evec))\n                \n    }\n    \n    result <- do.call(rbind, result_ls)\n    result <- xts(result, index(x)[width:n_rows])\n    colnames(result) <- colnames(x)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_df <- roll_eigen1(overlap_x_df, width, comp)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=576}\n:::\n:::\n\n\n-   <https://quant.stackexchange.com/a/3095>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroll_eigen2 <- function(x, width, comp) {\n    \n    n_rows <- nrow(x)\n    result_ls <- list()\n    \n    for (i in width:n_rows) {\n        \n        idx <- max(i - width + 1, 1):i\n        evec <- eigen_vecs(x[idx, ])[ , comp]\n                \n        if (i > width) {\n            \n            similarity <- evec %*% result_ls[[length(result_ls)]]\n            evec <- as.vector(sign(similarity)) * evec\n            result_ls <- append(result_ls, list(evec))\n            \n        } else {\n            result_ls <- append(result_ls, list(evec))\n        }\n                \n    }\n    \n    result <- do.call(rbind, result_ls)\n    result <- xts(result, index(x)[width:n_rows])\n    colnames(result) <- colnames(x)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_df <- roll_eigen2(overlap_x_df, width, comp)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=576}\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}