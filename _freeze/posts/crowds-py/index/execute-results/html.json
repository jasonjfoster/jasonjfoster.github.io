{
  "hash": "e02bbc3155e9e567806e4bab5400846c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Crowds\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - python\ndraft: true\n---\n\n::: {.cell}\n\n```{.python .cell-code}\nfactors_r = [\"SP500\"] # \"SP500\" does not contain dividends\nfactors_d = [\"DTB3\"]\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n# Parse web\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport requests\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_crumb_and_cookie():\n    \n    session = requests.Session()\n    \n    headers = {\n        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36\"\n    }\n    \n    session.headers.update(headers)\n\n    response = session.get(\"https://query1.finance.yahoo.com/v1/test/getcrumb\")\n\n    crumb = response.text.strip()\n    cookie = session.cookies.get_dict()\n\n    return crumb, cookie\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_yhoo():\n\n    crumb, cookie = get_crumb_and_cookie()\n    \n    params = {\n        \"crumb\": crumb,\n        \"lang\": \"en-US\",\n        \"region\": \"US\",\n        \"formatted\": \"true\",\n        \"corsDomain\": \"finance.yahoo.com\",\n    }\n    \n    api_url = \"https://query1.finance.yahoo.com/v1/finance/screener\"\n    \n    payload = {\n        \"size\": 250,\n        \"offset\": 0,\n        \"sortField\": \"fundnetassets\",\n        \"sortType\": \"DESC\",\n        \"quoteType\": \"MUTUALFUND\",\n        \"topOperator\": \"AND\",\n        \"query\": {\n            \"operator\": \"AND\",\n            \"operands\": [\n                {\n                    \"operator\": \"or\",\n                    \"operands\": [\n                        {\n                            \"operator\": \"EQ\",\n                            \"operands\": [\"categoryname\", \"Tactical Allocation\"]\n                        }\n                    ]\n                }\n            ]\n        },\n        \"userId\": \"\",\n        \"userIdType\": \"guid\"\n    }\n    \n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36\"\n    } \n    \n    with requests.session() as s:\n        \n        for key, value in cookie.items():\n            s.cookies.set(key, value)\n            \n        response = s.post(api_url, params = params, json = payload, headers = headers)\n\n        return response.json()\n```\n:::\n\n\n# Optimization\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport cvxpy as cp\nimport yfinance as yf\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef min_rss_optim(x, y):\n    \n    w = cp.Variable(x.shape[1])\n    \n    objective = cp.Minimize(cp.sum_squares(y - x @ w))\n    \n    constraints = [cp.sum(w) == 1, w >= 0, w <= 1]\n    \n    problem = cp.Problem(objective, constraints)\n    problem.solve()\n    \n    return w.value\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nyhoo_ls = get_yhoo()\nyhoo_df = pd.DataFrame(yhoo_ls[\"finance\"][\"result\"][0][\"quotes\"])\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nyhoo_df[\"netAssets_raw\"] = yhoo_df[\"netAssets\"].apply(lambda x: x[\"raw\"])\nsorted_df = yhoo_df.sort_values(by = [\"netAssets_raw\", \"firstTradeDateMilliseconds\"])\ntickers = sorted_df.loc[~sorted_df[\"netAssets_raw\"].duplicated(), \"symbol\"].tolist()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nallocations = [\"AOK\", \"AOM\", \"AOR\", \"AOA\"]\ntickers = tickers + allocations\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nn_rows = overlap_df.shape[0]\nresult_ls = []\nindex_ls = []\n\n# for i in range(width - 1, n_rows):\nfor i in range(n_rows - 1, n_rows):\n  \n  idx = range(max(i - width + 1, 0), i + 1)\n  x_subset = overlap_x_df.iloc[idx]\n  y_subset = overlap_y_df.iloc[idx]\n  params_ls = []\n  \n  for j in [ticker for ticker in tickers if ticker not in allocations]:\n    \n    idx = ~np.isnan(x_subset).any(axis = 1) & ~np.isnan(y_subset[j])\n    x_complete = x_subset[idx].values\n    y_complete = y_subset.loc[idx, j].values\n    \n    if (x_complete.shape[0] > 0) and (y_complete.size > 0):\n        \n      params = min_rss_optim(x_complete, y_complete)\n      params_ls.append(params)\n  \n  if params_ls:\n    \n    result_ls.append(np.mean(params_ls, axis = 0))\n    index_ls.append(overlap_x_df.index[i])\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# position_df = pd.DataFrame(result_ls, index = index_ls, columns = factors)\nposition_df = pd.DataFrame(result_ls, index = [overlap_df.index[-1]],\n                           columns = factors)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nposition_df.tail()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               SP500      DTB3\n2024-11-22  0.624036  0.375964\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}