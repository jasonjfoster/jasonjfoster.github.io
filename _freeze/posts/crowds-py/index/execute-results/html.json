{
  "hash": "d215fe89080ac7e7e56a5f89ea1b08af",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Crowds\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - python\ndraft: true\n---\n\n::: {.cell}\n\n```{.python .cell-code}\nfactors_r = [\"SP500\"] # \"SP500\" does not contain dividends\nfactors_d = [\"SOFR\"]\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n# Parse web\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport requests\nfrom lxml import html\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_nth(x, n, offset = 0):\n    \n    result = x[offset::n]\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_text(x, n = 0):\n    \n    result_ls = []\n    \n    for i in x:\n      \n        if (len(i) == 0):\n            result_ls.append(i.text_content()) # types\n        else:\n            result_ls.append(i[n].text_content()) # names and tickers\n    \n    return result_ls\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_mstar():\n    \n    i = 0\n    status = True\n    names_ls = []\n    tickers_ls = []\n    types_ls = []\n\n    while status:\n\n        i += 1\n\n        url = \"https://www.morningstar.com/asset-allocation-funds?page=\" + str(i)\n        response = requests.get(url)\n        \n        tree = html.fromstring(response.content)\n        table = tree.xpath(\"//div[@class='topic__table-container']\")\n\n        if (len(table) == 0):\n            status = False\n        else:\n\n            names_tickers = tree.xpath(\"//a[@class='mdc-link__mdc mdc-link--no-visited__mdc mdc-link--data-table__mdc']\")\n            types = tree.xpath(\"//span[@class='mdc-locked-text__mdc mdc-string']\")\n            \n        names_ls.extend(get_text(get_nth(names_tickers, 2)))\n        tickers_ls.extend(get_text(get_nth(names_tickers, 2, 1)))\n        types_ls.extend(get_text(get_nth(types, 5, 2)))\n\n    result = pd.DataFrame({\n      \"name\": names_ls,\n      \"ticker\": tickers_ls,\n      \"type\": types_ls\n    })\n    \n    return result\n```\n:::\n\n\n# Optimization\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport cvxpy as cp\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef min_rss_optim(x, y):\n    \n    w = cp.Variable(x.shape[1])\n    \n    objective = cp.Minimize(cp.sum_squares(y - x @ w))\n    \n    constraints = [cp.sum(w) == 1, w >= 0, w <= 1]\n    \n    problem = cp.Problem(objective, constraints)\n    problem.solve()\n    \n    return w.value\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nmstar_df = get_mstar()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ntickers = mstar_df.loc[mstar_df[\"type\"] == \"Tactical Allocation\", \"ticker\"].tolist()\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# n_rows = overlap_df.shape[0]\nresult_ls = []\n\n# for i in range(width - 1, n_rows):\nfor i in range(width - 1, width):\n  \n  idx = range(max(i - width + 1, 0), i + 1)\n  x_subset = overlap_x_df.iloc[idx]\n  y_subset = overlap_y_df.iloc[idx]\n  params_ls = []\n  \n  for j in tickers:\n  \n    params = min_rss_optim(x_subset.values, y_subset.loc[:, j].values)\n    params_ls.append(params)\n  \n  result_ls.append(np.mean(params_ls, axis = 0))\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# position_df = pd.DataFrame(result_ls, index = overlap_df.index[(width - 1):],\n#                            columns = factors)\nposition_df = pd.DataFrame(result_ls, index = [overlap_df.index[-1]],\n                           columns = factors)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nposition_df.tail()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               SP500      SOFR\n2024-03-13  0.613209  0.386791\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}