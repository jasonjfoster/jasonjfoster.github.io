{
  "hash": "0b2d80986a7fc182b2716b975a63005d",
  "result": {
    "markdown": "---\ntitle: \"Portfolios\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - python\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\nlibrary(data.table)\nsource(\"../plot/theme_jjf.R\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nimport pandas_datareader as pdr\nfrom scipy.stats import norm, chi2\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfactors_r = [\"SP500\", \"DTWEXAFEGS\"] # \"SP500\" does not contain dividends; note: \"DTWEXM\" discontinued as of Jan 2020\nfactors_d = [\"DGS10\", \"BAMLH0A0HYM2\"]\nfactors = factors_r + factors_d\nwidth = 252\nscale = {\"periods\": 252, \"overlap\": 5}\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n-   <https://pandas-datareader.readthedocs.io/en/latest/remote_data.html>\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlevels_df = pdr.get_data_fred(factors, start = \"1900-01-01\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nreturns_df = levels_df.apply(lambda x: np.log(x).diff() if x.name in factors_r else -x.diff() / 100)\noverlap_df = returns_df.rolling(scale[\"overlap\"], min_periods = 1).mean()\nreturns_df = pd.concat([returns_df, overlap_df], keys = [\"returns\", \"overlap\"], axis = 1)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# import datetime\nfrom scipy.optimize import minimize\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ntickers = [\"BAICX\"] # fund inception date is \"2011-11-28\"\nprices_df = pdr.get_data_tiingo(tickers, start = \"1900-01-01\", api_key = os.getenv(\"TIINGO_API_KEY\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nC:\\Users\\jason\\AppData\\Local\\R-MINI~1\\envs\\R-RETI~1\\lib\\site-packages\\pandas_datareader\\tiingo.py:234: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only\n  return pd.concat(dfs, self._concat_axis)\n```\n:::\n\n```{.python .cell-code}\nprices_df = prices_df.pivot_table(index = \"date\", columns = \"symbol\", values = \"adjClose\")\nprices_df.index = prices_df.index.tz_localize(None)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nreturns_cols = list(zip([\"returns\"], tickers))\noverlap_cols = list(zip([\"overlap\"], tickers))\nreturns_df[returns_cols] = np.log(prices_df).diff()\nreturns_df[overlap_cols] = returns_df[returns_cols].rolling(scale[\"overlap\"], min_periods = 1).mean()\nreturns_df.sort_index(axis = 1, inplace = True)\n```\n:::\n\n\n## Factor models\n\n### Ordinary least squares\n\n#### Coefficients\n\n$$\n\\begin{aligned}\n\\hat{\\beta}=(X^\\mathrm{T}WX)^{-1}X^\\mathrm{T}Wy\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# https://faculty.washington.edu/ezivot/research/factormodellecture_handout.pdf\ndef lm_coef(x, y, weights, intercept):\n    \n    if (intercept): x = sm.add_constant(x)\n        \n    result = np.matmul(np.linalg.inv(np.matmul(x.T, np.multiply(weights, x))),\n                       np.matmul(x.T, np.multiply(weights, y)))\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nintercept = True\n# weights = np.matrix([0.9 ** i for i in range(width - 1, -1, -1)]).reshape((width, 1))\nweights = np.matrix([1] * width).reshape((width, 1))\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\noverlap_x_df = returns_df.dropna()[\"overlap\"][factors]\noverlap_y_df = returns_df.dropna()[\"overlap\"][tickers]\noverlap_x_mat = np.matrix(overlap_x_df[-width:])\noverlap_y_mat = np.matrix(overlap_y_df[-width:])\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlm_coef(overlap_x_mat, overlap_y_mat, weights, intercept)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([-1.11871891e-05,  1.99036614e-01, -1.38082089e-01,  2.57225254e+00,\n        1.69074657e+00])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nif (intercept): overlap_x_mat = sm.add_constant(overlap_x_mat)\n    \nfit = sm.WLS(overlap_y_mat, overlap_x_mat, weights = weights).fit()\n\nif (intercept): overlap_x_mat = overlap_x_mat[:, 1:]\n\nfit.params\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([-1.11871891e-05,  1.99036614e-01, -1.38082089e-01,  2.57225254e+00,\n        1.69074657e+00])\n```\n:::\n:::\n\n\n#### R-squared\n\n$$\n\\begin{aligned}\nR^{2}=\\frac{\\hat{\\beta}^\\mathrm{T}(X^\\mathrm{T}WX)\\hat{\\beta}}{y^\\mathrm{T}Wy}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef lm_rsq(x, y, weights, intercept):\n            \n    coef = np.matrix(lm_coef(x, y, weights, intercept))\n    \n    if (intercept):\n        \n        weights_ls = np.array(weights).reshape(-1).tolist()\n        \n        x = sm.add_constant(x)\n        x = x - np.average(x, axis = 0, weights = weights_ls)\n        y = y - np.average(y, axis = 0, weights = weights_ls)\n        \n    result = np.matmul(coef, np.matmul(np.matmul(x.T, np.multiply(weights, x)), coef.T)) / \\\n        (np.matmul(y.T, np.multiply(weights, y)))\n    \n    return result.item()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlm_rsq(overlap_x_mat, overlap_y_mat, weights, intercept)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.8497723857546378\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfit.rsquared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.8497723857546384\n```\n:::\n:::\n\n\n#### Standard errors\n\n$$\n\\begin{aligned}\n\\sigma_{\\hat{\\beta}}^{2}&=\\sigma_{\\varepsilon}^{2}(X^\\mathrm{T}WX)^{-1}\\\\\n&=\\frac{(1-R^{2})}{n-p}(X^\\mathrm{T}WX)^{-1}\\\\\n&=\\frac{SSE}{df_{E}}(X^\\mathrm{T}WX)^{-1}\\\\\n\\sigma_{\\hat{\\alpha}}^{2}&=\\sigma_{\\varepsilon}^{2}\\left(\\frac{1}{n}+\\mu^\\mathrm{T}(X^\\mathrm{T}WX)^{-1}\\mu\\right)\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# http://people.duke.edu/~rnau/mathreg.htm\ndef lm_se(x, y, weights, intercept):\n    \n    n_rows = x.shape[0]\n    n_cols = x.shape[1]\n    \n    rsq = lm_rsq(x, y, weights, intercept)\n    \n    if (intercept):\n        \n        weights_ls = np.array(weights).reshape(-1).tolist()\n        \n        x = sm.add_constant(x)\n        y = y - np.average(y, axis = 0, weights = weights_ls)\n        \n        df_resid = n_rows - n_cols - 1 \n        \n    else:\n        df_resid = n_rows - n_cols        \n    \n    var_y = np.matmul(y.T, np.multiply(weights, y))\n    var_resid = (1 - rsq) * var_y / df_resid\n    \n    result = np.sqrt(var_resid * np.linalg.inv(np.matmul(x.T, np.multiply(weights, x))).diagonal())\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlm_se(overlap_x_mat, overlap_y_mat, weights, intercept)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([5.17600076e-05, 1.77837174e-02, 3.46178402e-02, 1.78768121e-01,\n       1.51361715e-01])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfit.bse\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([5.17600076e-05, 1.77837174e-02, 3.46178402e-02, 1.78768121e-01,\n       1.51361715e-01])\n```\n:::\n:::\n\n\n### Standalone risk\n\n$$\n\\begin{aligned}\n\\text{SAR}_{k}&=\\sqrt{w_{k}^{2}\\sigma_{k}^{2}}\\\\\n\\text{SAR}_{\\varepsilon}&=\\sqrt{(1-R^{2})\\sigma_{y}^{2}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef cov_wt(x, weights, center):\n    \n    sum_w = sum(weights)\n    sumsq_w = sum(np.power(weights, 2))\n    \n    if (center):\n    \n        weights_ls = np.array(weights).reshape(-1).tolist()\n        x = x - np.average(x, axis = 0, weights = weights_ls)\n    \n    result = np.matmul(x.T, np.multiply(weights, x)) / (sum_w - sumsq_w / sum_w)\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef lm_sar(x, y, weights, intercept):\n    \n    coef = lm_coef(x, y, weights, intercept)\n    rsq = lm_rsq(x, y, weights, intercept)\n    \n    if (intercept): x = sm.add_constant(x)\n    \n#     weights_ls = np.array(weights).reshape(-1)\n#     sigma = np.cov(np.concatenate((x, y), axis = 1).T,\n#                    aweights = weights_ls)\n    sigma = cov_wt(np.concatenate((x, y), axis = 1), weights, intercept)\n    sar = np.multiply(np.power(coef, 2).T, sigma[:-1, :-1].diagonal())\n    sar_eps = (1 - rsq) * sigma[-1, -1]\n    \n    result = np.sqrt(np.concatenate((np.matrix(sigma[-1, -1]),\n                                     np.matrix(sar),\n                                     np.matrix(sar_eps)), axis = 1))\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlm_sar(overlap_x_mat, overlap_y_mat, weights, intercept) * np.sqrt(scale[\"periods\"]) * np.sqrt(scale[\"overlap\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.07370702, 0.        , 0.02986623, 0.00914208, 0.03164923,\n       0.02754505, 0.02856826])\n```\n:::\n:::\n\n\n### Risk contribution\n\n$$\n\\begin{aligned}\n\\text{MCR}&=w^\\mathrm{T}\\frac{\\partial\\sigma_{y}}{\\partial w}\\\\\n&=w^\\mathrm{T}\\frac{\\Sigma w}{\\sigma_{y}}\\\\\n\\text{MCR}_{\\varepsilon}&=\\sigma_{y}-\\sum_{k=1}^{n}\\text{MCR}_{k}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# http://faculty.washington.edu/ezivot/research/factormodelrisklecture_handout.pdf\ndef lm_mcr(x, y, weights, intercept):\n    \n    coef = np.matrix(lm_coef(x, y, weights, intercept)).T\n    rsq = lm_rsq(x, y, weights, intercept)\n        \n    if (intercept): x = sm.add_constant(x)\n    \n#     weights_ls = np.array(weights).reshape(-1)        \n#     sigma = np.cov(np.concatenate((x, y), axis = 1).T,\n#                    aweights = weights_ls)\n    sigma = cov_wt(np.concatenate((x, y), axis = 1), weights, intercept)\n    mcr = np.multiply(coef, np.matmul(sigma[:-1, :-1], coef)) / np.sqrt(sigma[-1, -1])\n    mcr_eps = np.sqrt(sigma[-1, -1]) - sum(mcr)\n    \n    result = np.concatenate((np.sqrt(np.matrix(sigma[-1, -1])),\n                             np.matrix(mcr).T,\n                             np.matrix(mcr_eps)), axis = 1)\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlm_mcr(overlap_x_mat, overlap_y_mat, weights, intercept) * np.sqrt(scale[\"periods\"]) * np.sqrt(scale[\"overlap\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 0.07370702, -0.        ,  0.02368613,  0.00511232,  0.01746792,\n        0.01636783,  0.01107283])\n```\n:::\n:::\n\n\n### Implied shocks\n\n$$\n\\begin{aligned}\n\\hat{\\beta}&=(Z^\\mathrm{T}WZ)^{-1}Z^\\mathrm{T}WX\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef implied_shocks(shocks, x, z, weights):\n    \n    beta = np.matmul(np.linalg.inv(np.matrix(np.matmul(z.T, np.multiply(weights, z)))),\n                     np.matrix(np.matmul(z.T, np.multiply(weights, x))))\n    \n    result = np.matmul(shocks, beta)\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nshocks = np.array([-0.1, 0.1])\noverlap_z_mat = overlap_x_mat[:, [0, 1]]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimplied_shocks(shocks, overlap_x_mat, overlap_z_mat, weights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([-0.1       ,  0.1       , -0.0094656 , -0.00277652])\n```\n:::\n:::\n\n\n### Stress P&L\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef pnl_stress(shocks, x, y, z, weights, intercept):\n    \n    coef = lm_coef(x, y, weights, intercept)\n    \n    if (intercept): x = sm.add_constant(x)\n    \n    result = np.multiply(coef.T, implied_shocks(shocks, x, z, weights))\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npnl_stress(shocks, overlap_x_mat, overlap_y_mat, overlap_z_mat, weights, intercept)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 5.71524767e-05, -1.99036614e-02, -1.38082089e-02, -2.43479180e-02,\n       -4.69439434e-03])\n```\n:::\n:::\n\n\n## Principal component analysis\n\nUnderlying returns are structural bets that can be analyzed through dimension reduction techniques such as principal components analysis (PCA). Most empirical studies apply PCA to a covariance matrix (_note: for multi-asset portfolios, use the correlation matrix because asset-class variances are on different scales_) of equity returns (yield changes) and find that movements in the equity markets (yield curve) can be explained by a subset of principal components. For example, the yield curve can be decomposed in terms of shift, twist, and butterfly, respectively. \n\n### Eigendecomposition\n\n$$\n\\begin{aligned}\n\\boldsymbol{\\Sigma}&=\\lambda_{1}\\mathbf{v}_{1}\\mathbf{v}_{1}^\\mathrm{T}+\\lambda_{2}\\mathbf{v}_{2}\\mathbf{v}_{2}^\\mathrm{T}+\\cdots+\\lambda_{k}\\mathbf{v}_{k}\\mathbf{v}_{k}^\\mathrm{T}\\\\\n&=V\\Lambda V^{\\mathrm{T}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# https://www.r-bloggers.com/fixing-non-positive-definite-correlation-matrices-using-r-2/\ndef eigen_decomp(x, comps):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    L = L[idx]\n    V = V[:, idx]\n        \n    L = L[:comps]\n    V = V[:, :comps]\n    \n    result = np.matmul(V, np.multiply(L, V.T))\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncomps = 1\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\neigen_decomp(overlap_x_mat, comps) * scale[\"periods\"] * scale[\"overlap\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([[ 2.23562009e-02, -4.98318737e-03,  5.09362796e-04,\n         1.47970609e-03],\n       [-4.98318737e-03,  1.11075028e-03, -1.13536744e-04,\n        -3.29825838e-04],\n       [ 5.09362796e-04, -1.13536744e-04,  1.16053018e-05,\n         3.37135649e-05],\n       [ 1.47970609e-03, -3.29825838e-04,  3.37135649e-05,\n         9.79383806e-05]])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# np.cov(overlap_x_mat.T) * scale[\"periods\"] * scale[\"overlap\"]\n```\n:::\n\n\n### Variance explained\n\nWe often look at the proportion of variance explained by the first $i$ principal components as an indication of how many components are needed.\n\n$$\n\\begin{aligned}\n\\frac{\\sum_{j=1}^{i}{\\lambda_{j}}}{\\sum_{j=1}^{k}{\\lambda_{j}}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef variance_explained(x):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))   \n    idx = L.argsort()[::-1]\n    L = L[idx]\n    \n    result = L.cumsum() / L.sum()\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nvariance_explained(overlap_x_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.86308821, 0.990378  , 0.99663678, 1.        ])\n```\n:::\n:::\n\n\n### Cosine similarity\n\nAlso, a challenge of rolling PCA is to try to match the eigenvectors: may need to change the sign and order.\n\n$$\n\\begin{aligned}\n\\text{similarity}=\\frac{\\mathbf{A}\\cdot\\mathbf{B}}{\\|\\mathbf{A}\\|\\|\\mathbf{B}\\|}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef eigen_vals(x):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    L = L[idx]\n    \n    return pd.DataFrame(L)\n\ndef eigen_vecs(x):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    V = V[:, idx]\n    \n    return pd.DataFrame(V)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef roll_eigen1(x, width, comp):\n    \n    n_rows = len(x)\n    result = pd.DataFrame()\n    \n    for i in range(width - 1, n_rows):\n        \n        idx = range(max(i - width + 1, 0), i + 1)\n        evec = eigen_vecs(x.iloc[idx]).iloc[:, comp - 1]\n        result = result.append(evec.transpose())\n    \n    result.index = x.index[(width - 1):]\n    result.columns = x.columns\n    \n    return result  \n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncomp = 1\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nraw_df = roll_eigen1(overlap_x_df, width, comp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_mlt <- melt(as.data.table(py$raw_df, keep.rownames = \"index\"), id.vars = \"index\")\nraw_mlt[ , index := as.Date(index)]\nraw_plt <- plot_ts(raw_mlt, title = \"Eigenvector 1Y\")\nprint(raw_plt)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-43-1.png){width=576}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# https://quant.stackexchange.com/a/3095\ndef roll_eigen2(x, width, comp):\n    \n    n_rows = len(x)\n    result = pd.DataFrame()\n    \n    for i in range(width - 1, n_rows):\n        \n        idx = range(max(i - width + 1, 0), i + 1)\n        evec = eigen_vecs(x.iloc[idx]).iloc[:, comp - 1]\n        \n        if i > width - 1:\n            \n            similarity = np.matmul(np.matrix(evec),\n                                   np.matrix(result.iloc[-1, :]).T)\n            evec = pd.DataFrame(np.multiply(np.sign(similarity), np.matrix(evec))) \n            result = result.append(evec)\n            \n        else:\n            result = result.append(evec.transpose())\n    \n    result.index = x.index[(width - 1):]\n    result.columns = x.columns\n    \n    return result  \n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nclean_df = roll_eigen2(overlap_x_df, width, comp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_mlt <- melt(as.data.table(py$clean_df, keep.rownames = \"index\"), id.vars = \"index\")\nclean_mlt[ , index := as.Date(index)]\nclean_plt <- plot_ts(clean_mlt, title = \"Eigenvector 1Y\")\nprint(clean_plt)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-46-1.png){width=576}\n:::\n:::\n\n\n### Contour ellipsoid\n\nThe contours of a multivariate normal (MVN) distribution are ellipsoids centered at the mean. The directions of the axes are given by the eigenvectors of the covariance matrix and squared lengths are given by the eigenvalues:\n\n$$\n\\begin{aligned}\n({\\mathbf{x}}-{\\boldsymbol{\\mu}})^{\\mathrm{T}}{\\boldsymbol{\\Sigma}}^{-1}({\\mathbf{x}}-{\\boldsymbol{\\mu}})=c^{2}\n\\end{aligned}\n$$\n\nOr, in general parametric form:\n\n$$\n\\begin{aligned}\nX(t)&=X_{c}+a\\,\\cos t\\,\\cos \\varphi -b\\,\\sin t\\,\\sin \\varphi\\\\\nY(t)&=Y_{c}+a\\,\\cos t\\,\\sin \\varphi +b\\,\\sin t\\,\\cos \\varphi\n\\end{aligned}\n$$\nwhere $t$ varies from $0,\\ldots,2\\pi$. Here $(X_{c},Y_{c})$ is the center of the ellipse and $\\varphi$ is the angle between the x-axis and the major axis of the ellipse.\n\nSpecifically:\n\n$$\n\\begin{aligned}\n&\\text{Center: }\\boldsymbol{\\mu}=(X_{c},Y_{c})\\\\\n&\\text{Radius: }c^{2}= \\chi_{\\alpha}^{2}(df)\\\\\n&\\text{Length: }a=c\\sqrt{\\lambda_{k}}\\\\\n&\\text{Angle of rotation: }\\varphi=\\text{atan2}\\left(\\frac{V_{k}(2)}{V_{k}(1)}\\right)\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# https://www.visiondummy.com/2014/04/draw-error-ellipse-representing-covariance-matrix/\n# https://maitra.public.iastate.edu/stat501/lectures/MultivariateNormalDistribution-I.pdf\n# https://en.wikipedia.org/wiki/Multivariate_normal_distribution\n# https://en.wikipedia.org/wiki/Ellipse#General_parametric_form\ndef ellipse(n_sim, x, y, sigma):\n    \n    data = np.concatenate((x, y), axis = 1)\n    L, V = np.linalg.eig(np.cov(data.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    L = L[idx]\n    V = V[:, idx]\n    \n    c = np.sqrt(chi2.ppf(norm.cdf(sigma), 2))\n    t = np.linspace(0, 2 * np.pi, n_sim)\n    phi = np.arctan2(V[1, 0], V[0, 0])\n    a = c * np.sqrt(L[0]) * np.cos(t)\n    b = c * np.sqrt(L[1]) * np.sin(t)\n    R = np.matrix([[np.cos(phi), np.sin(phi)], [-np.sin(phi), np.cos(phi)]])\n    r = np.matmul(np.matrix([a, b]).T, R)\n    \n    result = np.add(r, np.mean(data, axis = 0)) # 2D only\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nreturns_x_df = returns_df.dropna()[\"returns\"][factors] \nreturns_x_mat = np.matrix(returns_x_df) # extended history\nellipse_x_mat = ellipse(1000, returns_x_mat[:, [0]], returns_x_mat[:, [2]], 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nellipse_plt <- plot_scatter(data.table(py$returns_x_mat[ , c(1, 3)]), x = \"V1\", y = \"V2\",\n                            title = \"Return 1D (%)\", xlab = \"SP500\", ylab = \"DGS10\") +\n  geom_point(data = data.table(py$ellipse_x_mat), aes(x = V1 * 100, y = V2 * 100))\nprint(ellipse_plt)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-49-1.png){width=288}\n:::\n:::\n\n\n### Principal component regression\n\n#### Coefficients\n\n$$\n\\begin{aligned}\nW_{k}&=\\mathbf{X}V_{k}=[\\mathbf{X}\\mathbf{v}_{1},\\ldots,\\mathbf{X}\\mathbf{v}_{k}]\\\\\n{\\widehat{\\gamma}}_{k}&=\\left(W_{k}^\\mathrm{T}W_{k}\\right)^{-1}W_{k}^\\mathrm{T}\\mathbf{Y}\\\\\n{\\widehat{\\boldsymbol{\\beta}}}_{k}&=V_{k}{\\widehat{\\gamma}}_{k}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# https://en.wikipedia.org/wiki/Principal_component_regression\ndef pcr_coef(x, y, comps):\n    \n    x = x - np.average(x, axis = 0)\n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    V = V[:, idx]\n    \n    W = np.matmul(x, V)\n    gamma = np.matmul(np.linalg.inv(np.matmul(W.T, W)), np.matmul(W.T, y))\n    \n    result = np.matmul(V[:, :comps], gamma[:comps])\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nscale_x_mat = (overlap_x_mat - np.average(overlap_x_mat, axis = 0)) \\\n    / np.std(overlap_x_mat, axis = 0, ddof = 1)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npcr_coef(scale_x_mat, overlap_y_mat, comps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 0.00081854, -0.0007194 ,  0.00053527,  0.00055451])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npcr_coef(overlap_x_mat, overlap_y_mat, comps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 0.37960728, -0.0846143 ,  0.00864896,  0.02512534])\n```\n:::\n:::\n\n\n#### R-squared\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef pcr_rsq(x, y, comps):\n    \n    coef = np.matrix(pcr_coef(x, y, comps))\n    \n    x = x - np.average(x, axis = 0)\n    y = y - np.average(y, axis = 0)\n    \n    result = np.matmul(coef, np.matmul(np.matmul(x.T, x), coef.T)) / (np.matmul(y.T, y))\n    \n    return result.item()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npcr_rsq(scale_x_mat, overlap_y_mat, comps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.8073284709633463\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npcr_rsq(overlap_x_mat, overlap_y_mat, comps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.6594954620620236\n```\n:::\n:::\n\n\n#### Standard errors\n\n$$\n\\begin{aligned}\n\\text{Var}({\\widehat{\\boldsymbol{\\beta}}}_{k})&=\\sigma^{2}V_{k}(W_{k}^\\mathrm{T}W_{k})^{-1}V_{k}^\\mathrm{T}\\\\\n&=\\sigma^{2}V_{k}\\text{diag}\\left(\\lambda_{1}^{-1},\\ldots,\\lambda_{k}^{-1}\\right)V_{k}^\\mathrm{T}\\\\\n&=\\sigma^{2}\\sum_{j=1}^{k}{\\frac{\\mathbf{v}_{j}\\mathbf{v}_{j}^\\mathrm{T}}{\\lambda_{j}}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# unable to verify the result\ndef pcr_se(x, y, comps):\n    \n    n_rows = x.shape[0]\n    n_cols = x.shape[1]\n    \n    rsq = pcr_rsq(x, y, comps)\n    \n    y = y - np.average(y, axis = 0)\n    \n    df_resid = n_rows - n_cols - 1\n    \n    var_y = np.matmul(y.T, y)   \n    var_resid = (1 - rsq) * var_y / df_resid\n    \n    pca = sm.multivariate.PCA(x, standardize = False, demean = True)\n    L = pca.eigenvals[:comps]\n    V = pca.eigenvecs[:, :comps]\n    \n    result = np.sqrt(var_resid * np.matmul(V, np.matmul(np.diag(1 / L), V.T)).diagonal())\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npcr_se(scale_x_mat, overlap_y_mat, comps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([2.54433179e-05, 2.23618138e-05, 1.66383917e-05, 1.72362464e-05])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npcr_se(overlap_x_mat, overlap_y_mat, comps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.01735568, 0.00386857, 0.00039543, 0.00114873])\n```\n:::\n:::\n\n\n### Marchenko–Pastur distribution\n\nMarchenko–Pastur distribution is the limiting distribution of eigenvalues of Wishart matrices as the matrix dimension $m$ and degrees of freedom $n$ both tend to infinity with ratio $m/n\\,\\to \\,\\lambda\\in(0,+\\infty)$:\n\n$$\n\\begin{aligned}\nd\\nu(x)&={\\frac {1}{2\\pi\\sigma ^{2}}}{\\frac{\\sqrt{(\\lambda_{+}-x)(x-\\lambda_{-})}}{\\lambda x}}\\,\\mathbf{1}_{x\\in[\\lambda_{-},\\lambda _{+}]}\\,dx\n\\end{aligned}\n$$\n\nwith \n\n$$\n\\begin{aligned}\n\\lambda_{\\pm}&=\\sigma^{2}(1\\pm{\\sqrt{\\lambda }})^{2}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# https://en.wikipedia.org/wiki/Marchenko%E2%80%93Pastur_distribution\n# https://faculty.baruch.cuny.edu/jgatheral/RandomMatrixCovariance2008.pdf\ndef dmp(x, sigma = 1):\n    \n    L, V = np.linalg.eig(np.cov(x.T, ddof = 1))\n    idx = L.argsort()[::-1]\n    L = L[idx]\n    \n    lmbda = x.shape[1] / x.shape[0]\n    lower = sigma * (1 - np.sqrt(lmbda)) ** 2\n    upper = sigma * (1 + np.sqrt(lmbda)) ** 2\n    \n    d = np.where((L <= lower) | (L >= upper), 0,\n                 1 / (2 * np.pi * sigma * lmbda * L) * np.sqrt((upper - L) * (L - lower)))\n    \n    return d\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nn_sim = 5000\nn_cols = 1000\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndata_sim = np.random.normal(size = n_sim * n_cols).reshape((n_sim, n_cols))\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nL, V = np.linalg.eig(np.cov(data_sim.T, ddof = 1))\nidx = L.argsort()[::-1]\nL = L[idx]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndmp_df = pd.DataFrame.from_dict({\"evals\": L,\n                                 \"dmp\": dmp(data_sim)})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndmp_plt <- plot_density(py$dmp_df, x = \"evals\", y = \"dmp\",\n                        title = \"Marchenko-Pastur distribution\", xlab = \"Eigenvalues\", ylab = \"Density\")\nprint(dmp_plt)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(density)` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-65-1.png){width=384}\n:::\n:::\n\n\n## Random portfolios\n\nNeed to generate uniformly distributed weights $\\mathbf{w}=(w_{1},w_{2},\\ldots,w_{N})$ such that $\\sum_{j=1}^{N}w_{i}=1$ and $w_{i}\\geq0$:\n\n* **Approach 1**: tempting to use $w_{i}=\\frac{u_{i}}{\\sum_{j=1}^{N}u_{i}}$ where $u_{i}\\sim U(0,1)$ but the distribution of $\\mathbf{w}$ is not uniform\n\n* **Approach 2**: instead, generate $\\text{Exp}(1)$ and then normalize\n\nCan also scale random weights by $M$, e.g. if sum of weights must be 10% then multiply weights by 10%.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef rand_weights1(n_sim, n_assets, lmbda):  \n    \n    rand_exp = np.matrix(np.random.uniform(size = (n_sim, n_assets)))\n    rand_exp_sum = np.sum(rand_exp, axis = 1)\n    \n    result = np.divide(rand_exp, rand_exp_sum)\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Methodology: uniform sampling from the simplex (http://mathoverflow.net/a/76258)\n# z ~ U(0, 1) then -ln(z) is an exponential(1) distribution\n# This is also known as generating a random vector from the symmetric Dirichlet distribution\ndef rand_weights2(n_sim, n_assets, lmbda):   \n    \n    rand_exp = np.matrix(-np.log(1 - np.random.uniform(size = (n_sim, n_assets))) / lmbda)\n    rand_exp_sum = np.sum(rand_exp, axis = 1)\n    \n    result = np.divide(rand_exp, rand_exp_sum)\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# 1. Generate n exponential(1) random variables x_1, x_2, ..., x_n\n# 2. Let y_i = x_i / (sum_{i = 1}^{n} x_i)\ndef rand_weights3(n_sim, n_assets, lmbda):\n    \n    rand_exp = np.matrix(np.random.exponential(size = (n_sim, n_assets)))\n    rand_exp_sum = np.sum(rand_exp, axis = 1)\n    \n    result = np.divide(rand_exp, rand_exp_sum)\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlmbda = 1\nn_assets = 3\nn_sim = 10000\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\napproach1 = rand_weights1(n_sim, n_assets, lmbda)\napproach2 = rand_weights2(n_sim, n_assets, lmbda)\napproach3 = rand_weights3(n_sim, n_assets, lmbda)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_pairs(as.data.table(py$approach1), title = \"Weight (%)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-71-1.png){width=384}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_pairs(as.data.table(py$approach2), title = \"Weight (%)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-72-1.png){width=384}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_pairs(as.data.table(py$approach3), title = \"Weight (%)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-73-1.png){width=384}\n:::\n:::\n\n\n### Random turnover\n\nHow to generate random weights between lower bound $a$ and upper bound $b$ that sum to zero?\n\n* **Approach 1**: tempting to multiply random weights by $M$ and then subtract by $\\frac{M}{N}$ but the distribution is not between $a$ and $b$\n\n* **Approach 2**: instead, use an iterative approach for random turnover:\n    1. Generate $N-1$ uniformly distributed weights between $a$ and $b$\n    2. For $u_{N}$ compute sum of values and subtract from $M$\n    3. If $u_{N}$ is between $a$ and $b$, then keep; otherwise, discard\n\nThen add random turnover to previous period's random weights.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef rand_iterative(n_assets, lower, upper, target):\n    \n    plug = False\n    \n    while not plug:\n        \n        result = np.random.uniform(low = lower, high = upper, size = n_assets - 1)\n        temp = target - sum(result)\n        \n        if ((temp <= upper) and (temp >= lower)):\n            plug = True\n        \n    result = np.append(result, temp)\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef rand_turnover1(n_sim, n_assets, lower, upper, target):\n    \n    rng = upper - lower\n    \n    result = rand_weights3(n_sim, n_assets, lmbda) * rng\n    result = result - rng / n_assets\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef rand_turnover2(n_sim, n_assets, lower, upper, target):\n    \n    result = np.matrix(rand_iterative(n_assets, lower, upper, target))\n    \n    while result.shape[0] < n_sim:\n    \n        temp = np.matrix(rand_iterative(n_assets, lower, upper, target))\n        result = np.concatenate((result, temp), axis = 0)\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlower = -0.05\nupper = 0.05\ntarget = 0\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\napproach1 = rand_turnover1(n_sim, n_assets, lower, upper, target)\napproach2 = rand_turnover2(n_sim, n_assets, lower, upper, target)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_pairs(as.data.table(py$approach1), title = \"Weight (%)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-79-1.png){width=384}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_pairs(as.data.table(py$approach2), title = \"Weight (%)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-80-1.png){width=384}\n:::\n:::\n\n\n## Mean-variance\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef geometric_mean(x, scale):\n    \n    result = np.prod(1 + x) ** (scale / x.shape[1]) - 1\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nmu = np.apply_along_axis(geometric_mean, 0, returns_x_mat, scale[\"periods\"])\nsigma = np.cov(overlap_x_mat.T, ddof = 1) * scale[\"periods\"] * scale[\"overlap\"]\n```\n:::\n\n\n### Maximum return\n\n$$\n\\begin{aligned}\n\\begin{array}{rrcl}\n\\displaystyle\\max_{x}&\\mu^{T}\\mathbf{w}\\\\\n\\textrm{s.t.}&\\mathbf{w}^T\\Sigma\\mathbf{w}&\\leq&\\sigma^{2}\\\\\n&e^T\\mathbf{w}&=&1\n\\end{array}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntarget = 0.06\nstart = np.array([1] * len(factors))\nbnds = [(np.finfo(float).eps, 1) for i in range(len(factors))]\ncons = [{\"type\": \"ineq\", \"fun\": lambda params, sigma, target: max_pnl_cons(params, sigma, target),\n         \"args\": (sigma, target)},\n        {\"type\": \"eq\", \"fun\": lambda params: np.sum(params) - 1}]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef max_pnl_cons(params, sigma, target):\n    \n    var = np.matmul(np.transpose(params), np.matmul(sigma, params))\n    \n    result = target ** 2 - var\n    \n    return result\n\ndef max_pnl_obj(params, mu):\n    \n    result = np.matmul(mu, params)\n    \n    return -result\n\ndef max_pnl_optim(params, mu):\n    \n    result = minimize(max_pnl_obj, params, args = (mu), bounds = bnds, constraints = cons)\n    \n    return result.x\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nparams1 = max_pnl_optim(start, mu)\nparams1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([4.37539218e-01, 5.62460782e-01, 2.22044605e-16, 2.22044605e-16])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.matmul(mu, params1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.04133894521237629\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.sqrt(np.matmul(np.transpose(params1), np.matmul(sigma, params1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.06000006431558848\n```\n:::\n:::\n\n\n### Minimum variance\n\n$$\n\\begin{aligned}\n\\begin{array}{rrcl}\n\\displaystyle\\min_{x}&\\mathbf{w}^T\\Sigma\\mathbf{w}\\\\\n\\textrm{s.t.}&\\mu^{T}\\mathbf{w}&\\geq&M\\\\\n&e^T\\mathbf{w}&=&1\n\\end{array}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntarget = 0.03\nstart = np.array([1] * len(factors))\ncons = [{\"type\": \"ineq\", \"fun\": lambda params, mu, target: min_risk_cons(params, mu, target),\n         \"args\": (mu, target)},\n        {\"type\": \"eq\", \"fun\": lambda params: np.sum(params) - 1}]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef min_risk_cons(params, mu, target):\n    \n    result = np.matmul(mu, params) - target\n    \n    return result\n\ndef min_risk_obj(params, sigma):\n    \n    result = np.matmul(np.transpose(params), np.matmul(sigma, params))\n    \n    return result\n\ndef min_risk_optim(params, sigma):\n    \n    result = minimize(min_risk_obj, params, args = (sigma), bounds = bnds, constraints = cons)\n    \n    return result.x\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nparams2 = min_risk_optim(start, sigma)\nparams2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.28582197, 0.54910829, 0.10805544, 0.0570143 ])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.matmul(mu, params2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.030000000029763933\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.sqrt(np.matmul(np.transpose(params2), np.matmul(sigma, params2))) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.04296084289445136\n```\n:::\n:::\n\n\n### Maximum ratio\n\n$$\n\\begin{aligned}\n\\begin{array}{rrcl}\n\\displaystyle\\max_{x}&\\mu^{T}\\mathbf{w}-\\frac{1}{2}\\delta(\\mathbf{w}^T\\Sigma\\mathbf{w})\\\\\n\\textrm{s.t.}&e^T\\mathbf{w}&=&1\n\\end{array}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\nir = 0.5\ntarget = ir / 0.06 # ir / std (see Black-Litterman)\nstart = np.array([1] * len(factors))\ncons = [{\"type\": \"eq\", \"fun\": lambda params: np.sum(params) - 1}]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(start)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 1 1 1]\n```\n:::\n\n```{.python .cell-code}\nprint(start.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(4,)\n```\n:::\n\n```{.python .cell-code}\nprint(mu)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0.07274677  0.01690674 -0.00105489  0.00066174]\n```\n:::\n\n```{.python .cell-code}\nprint(mu.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(4,)\n```\n:::\n\n```{.python .cell-code}\nprint(sigma)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 2.25161872e-02 -4.26101245e-03  4.41178041e-04  1.51807793e-03]\n [-4.26101245e-03  4.38344152e-03 -4.21280590e-04 -1.13499562e-04]\n [ 4.41178041e-04 -4.21280590e-04  1.51390635e-04 -2.06179097e-05]\n [ 1.51807793e-03 -1.13499562e-04 -2.06179097e-05  2.65417825e-04]]\n```\n:::\n\n```{.python .cell-code}\nprint(sigma.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(4, 4)\n```\n:::\n\n```{.python .cell-code}\nprint(np.matmul(np.transpose(start), np.matmul(sigma, start)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.021602128071028265\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef max_ratio_obj(params, mu, sigma, target):\n    \n    result = np.matmul(mu, params) - 0.5 * target * (np.matmul(np.transpose(params),\n                                                               np.matmul(sigma, params)))\n#     result = np.matmul(mu, params) / np.sqrt(np.matmul(np.transpose(params), np.matmul(sigma, params)))\n    \n    return -result\n\ndef max_ratio_optim(params, mu, sigma, target):\n    \n    result = minimize(max_ratio_obj, params, args = (mu, sigma, target), bounds = bnds,\n                      constraints = cons) \n    \n    return result.x\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nparams3 = max_ratio_optim(start, mu, sigma, target)\nparams3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([4.34472214e-01, 5.65527786e-01, 2.22044605e-16, 3.04010289e-16])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.matmul(mu, params3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.04116768362937637\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.sqrt(np.matmul(np.transpose(params3), np.matmul(sigma, params3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.05965147931510853\n```\n:::\n:::\n\n\n## Black-Litterman\n\n### Prior distribution\n\n$$\n\\begin{aligned}\n\\text{Risk aversion: } &\\lambda=\\frac{E(r)-r_{f}}{\\sigma^{2}}=\\frac{IR}{\\sigma}\\\\\n\\text{Implied returns: } &\\Pi=\\lambda\\Sigma w\\\\\n\\text{Distribution: } &N\\sim(\\Pi,\\tau\\Sigma)\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef implied_pnl(params, ir, sigma):\n    \n    lmbda = ir / np.sqrt(np.matmul(np.transpose(params), np.matmul(sigma, params)))\n    \n    result = np.matmul(lmbda * sigma, params)\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimplied_pnl(params3, ir, sigma)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 0.06180012,  0.00526111, -0.00039032,  0.00499045])\n```\n:::\n:::\n\n\n### Conditional distribution\n\n$$\n\\begin{aligned}\n\\text{Prior mean variance: } &\\tau\\in(0.01, 0.05)\\approx(0.025)\\\\\n\\text{Asset views: } &\\mathbf{P}={\\begin{bmatrix}\np_{11}&\\cdots&p_{1n}\\\\\n\\vdots&\\ddots&\\vdots\\\\\np_{k1}&\\cdots&p_{kn}\n\\end{bmatrix}}=\n{\\begin{bmatrix}\n0&0&0&0&0&0&1&0\\\\\n-1&1&0&0&0&0&0&0\\\\\n0&0&0.5&-0.5&0.5&-0.5&0&0\n\\end{bmatrix}}\\\\\n\\text{View returns: } &\\mathbf{Q}={\\begin{bmatrix}\nq_{1}\\\\\n\\vdots\\\\\nq_{k}\n\\end{bmatrix}}=\n{\\begin{bmatrix}\n0.0525\\\\\n0.0025\\\\\n0.0200\n\\end{bmatrix}}\\\\\n\\text{View confidence: } &\\mathbf{C}={\\begin{bmatrix}\nc_{1}\\\\\n\\vdots\\\\\nc_{k}\n\\end{bmatrix}}=\n{\\begin{bmatrix}\n0.2500\\\\\n0.5000\\\\\n0.6500\n\\end{bmatrix}}\\\\\n\\text{View covariance: } &\\mathbf{\\Omega}={\\begin{bmatrix}\n\\tau\\left(\\frac{1-c_{1}}{c_{1}}\\right)\\left(p_{1}\\Sigma p_{1}^{T}\\right)&0&0\\\\\n0&\\ddots&0\\\\\n0&0&\\tau\\left(\\frac{1-c_{k}}{c_{k}}\\right)\\left(p_{k}\\Sigma p_{k}^{T}\\right)\n\\end{bmatrix}}\\\\\n\\text{Distribution: } &N\\sim(\\mathbf{Q}, \\mathbf{\\Omega})\n\\end{aligned}\n$$\n\n### Posterior distribution\n\n$$\n\\begin{aligned}\n\\text{Implied returns: } &\\hat{\\Pi}=\\Pi+\\tau\\Sigma \\mathbf{P}^{T}\\left(\\tau \\mathbf{P}\\Sigma \\mathbf{P}^{T}+\\mathbf{\\Omega}\\right)^{-1}\\left(\\mathbf{Q}-\\mathbf{P}\\Pi^{T}\\right)\\\\\n\\text{Covariance: } &\\hat{\\Sigma}=\\Sigma+\\tau\\left[\\Sigma-\\Sigma\\mathbf{P}^{T}\\left(\\tau\\mathbf{P}\\Sigma\\mathbf{P}^{T}+\\mathbf{\\Omega}\\right)^{-1}\\tau\\mathbf{P}\\Sigma\\right]\\\\\n\\text{Weights: } &\\hat{w}=\\hat{\\Pi}\\left(\\lambda\\Sigma\\right)^{-1}\\\\\n\\text{Distribution: } &N\\sim\\left(\\left[\\left(\\tau\\Sigma\\right)^{-1}+\\mathbf{P}^{T}\\Omega^{-1}\\mathbf{P}\\right]^{-1}\\left[\\left(\\tau\\Sigma\\right)^{-1}\\Pi+\\mathbf{P}^{T}\\Omega^{-1}\\mathbf{Q}\\right],\\left[\\left(\\tau\\Sigma\\right)^{-1}+\\mathbf{P}^{T}\\Omega^{-1}\\mathbf{P}\\right]^{-1}\\right)\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef black_litterman(params, ir, sigma, views):\n    \n    # prior distribution\n    weights_prior = params\n    sigma_prior = sigma\n    lmbda = ir / np.sqrt(np.matmul(np.transpose(weights_prior), np.matmul(sigma_prior, weights_prior)))\n    pi_prior = np.transpose(np.matrix(np.matmul(lmbda * sigma_prior, weights_prior)))\n    \n    # matrix calculations\n    matmul_left = np.multiply(views[\"tau\"], np.matmul(sigma_prior, views[\"P\"].T))\n    matmul_mid = np.multiply(views[\"tau\"], np.matmul(views[\"P\"], np.matmul(sigma_prior, views[\"P\"].T)))\n    matmul_right = views[\"Q\"] - np.matmul(views[\"P\"], pi_prior)\n    \n    # conditional distribution\n    omega = np.diag(np.diag(np.matmul(np.diag([(1 - x) / x for x in views[\"C\"]]), matmul_mid)))\n    \n    # posterior distribution\n    pi_posterior = pi_prior + np.matmul(matmul_left, np.matmul(np.linalg.inv(matmul_mid + omega), matmul_right))\n    \n    sigma_posterior = sigma_prior + np.multiply(views[\"tau\"], sigma_prior) - \\\n        np.matmul(matmul_left, np.matmul(np.linalg.inv(matmul_mid + omega),\n                                         np.multiply(views[\"tau\"], np.matmul(views[\"P\"], sigma_prior))))\n    \n    weights_posterior = np.matmul(pi_posterior.T, np.linalg.inv(lmbda * sigma_prior))\n    \n    # implied confidence\n    pi_posterior_100 = pi_prior + np.matmul(matmul_left, np.matmul(np.linalg.inv(matmul_mid), matmul_right))\n    \n    weights_posterior_100 = np.matmul(pi_posterior_100.T, np.linalg.inv(lmbda * sigma_prior))\n    \n    implied_confidence = (weights_posterior - weights_prior) / (weights_posterior_100 - weights_prior)\n    \n    result = {\"implied_confidence\": implied_confidence,\n              \"weights_prior\": np.matrix(weights_prior),\n              \"weights_posterior\": weights_posterior,\n              \"pi_prior\": np.transpose(pi_prior),\n              \"pi_posterior\": np.transpose(pi_posterior),\n              \"sigma_prior\": sigma_prior,\n              \"sigma_posterior\": sigma_posterior}\n        \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ntau = 0.025\nP = np.diag([1] * len(factors))\nQ = np.transpose(np.matrix(implied_shocks([0.1], overlap_x_mat, overlap_x_mat[:, 0], 1)))\nC = [0.95] * len(factors)\nviews = {\"tau\": tau, \"P\": P, \"Q\": Q, \"C\": C}\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nbl = black_litterman(params3, ir, sigma, views)\nbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'implied_confidence': matrix([[ 0.97159292,  0.93400713, -0.37067746, -0.40614919]]), 'weights_prior': matrix([[4.34472214e-01, 5.65527786e-01, 2.22044605e-16, 3.04010289e-16]]), 'weights_posterior': matrix([[0.52802075, 0.02381873, 0.03199844, 0.01172265]]), 'pi_prior': matrix([[ 0.06180012,  0.00526111, -0.00039032,  0.00499045]]), 'pi_posterior': matrix([[ 0.09907076, -0.01810773,  0.00190707,  0.00671672]]), 'sigma_prior': array([[ 2.25161872e-02, -4.26101245e-03,  4.41178041e-04,\n         1.51807793e-03],\n       [-4.26101245e-03,  4.38344152e-03, -4.21280590e-04,\n        -1.13499562e-04],\n       [ 4.41178041e-04, -4.21280590e-04,  1.51390635e-04,\n        -2.06179097e-05],\n       [ 1.51807793e-03, -1.13499562e-04, -2.06179097e-05,\n         2.65417825e-04]]), 'sigma_posterior': array([[ 2.25429284e-02, -4.26136589e-03,  4.41212808e-04,\n         1.51825854e-03],\n       [-4.26136589e-03,  4.38877437e-03, -4.21313142e-04,\n        -1.13491831e-04],\n       [ 4.41212808e-04, -4.21313142e-04,  1.51575898e-04,\n        -2.06227402e-05],\n       [ 1.51825854e-03, -1.13491831e-04, -2.06227402e-05,\n         2.65737594e-04]])}\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nparams4 = np.array(bl[\"weights_posterior\"])[0]\nparams4 = params4 / sum(params4) # no leverage\nparams4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.88659454, 0.0399938 , 0.05372827, 0.01968339])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.matmul(mu, params4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.06512940361138682\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.sqrt(np.matmul(np.transpose(params4), np.matmul(sigma, params4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.13227699668169068\n```\n:::\n:::\n\n\n## Risk parity\n\nRisk parity is an approach to portfolio management that focuses on allocation of risk rather than allocation of capital. In a risk parity strategy, the asset allocations are leveraged, or deleveraged, to have equal risk contributions. Suppose that $\\mathbf{R}$ is a $T \\times N$ matrix of asset returns where the return of the $i^{th}$ asset is $R_{i,t}$ at time $t$. Define $\\Sigma$ to be the covariance matrix of $\\mathbf{R}$ and let $\\mathbf{w}=(w_{1},\\dots,w_{N})$ be a vector of asset weights. Then the volatility of the return of the strategy is $\\sigma_{P}=\\sqrt{\\mathbf{w}^T\\Sigma\\mathbf{w}}$ and, by Euler's Theorem, satisfies: \n\n$$\n\\begin{aligned}\n\\sigma_{P}&=\\sum_{i=1}^{N}w_{i}\\frac{\\partial\\sigma_{P}}{\\partial w_{i}}\\\\\n&=w_{1}\\frac{\\partial\\sigma_{P}}{\\partial w_{1}}+\\dots+w_{N}\\frac{\\partial\\sigma_{P}}{\\partial w_{N}}\n\\end{aligned}\n$$\n\nwhere each element is the risk contribution of the $i^{th}$ risky asset. The risk parity objective solves for weights such that each asset contributes equal risk using the following nonlinear constrained optimization problem:\n\n$$\n\\begin{aligned}\n\\begin{array}{rrcl}\n\\displaystyle\\max_{x}&\\displaystyle\\sum_{i=1}^{N}\\log(w_{i})\\\\\n\\textrm{s.t.}&\\sqrt{\\mathbf{w}^T\\Sigma\\mathbf{w}}&\\leq&\\sigma \n\\end{array}\n\\end{aligned}\n$$\n\nTo incorporate these conditions into one equation, introduce a new variable $\\lambda$ that is the Lagrange multiplier and define a new function $\\mathcal{L}$ as follows:\n\n$$\n\\begin{aligned}\n\\mathcal{L}(\\mathbf{w},\\lambda)&=\\sum_{i=1}^{N}\\log(w_{i})-\\lambda(\\sqrt{\\mathbf{w}^T\\Sigma\\mathbf{w}}-\\sigma)\n\\end{aligned}\n$$\n\nThen set the partial derivatives of $\\mathcal{L}$ equal to zero for each asset $i$:\n\n$$\n\\begin{aligned}\n\\frac{\\partial\\mathcal{L}(\\mathbf{w},\\lambda)}{\\partial w_{i}}&=\\frac{1}{w_{i}}-\\lambda\\frac{\\partial\\sigma_{P}}{\\partial w_{i}}=0\n\\Leftrightarrow\nw_{i}\\frac{\\partial\\sigma_{P}}{\\partial w_{i}}=\\frac{1}{\\lambda}\n\\end{aligned}\n$$\n\nNotice that $1/\\lambda$ is the risk contribution of the $i^{th}$ asset. Now use `Python` to maximize the Lagrangian numerically:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# http://faculty.washington.edu/ezivot/econ424/riskbudgetingslides.pdf\n# https://systematicinvestor.wordpress.com/2011/11/16/black-litterman-model/\n# https://cran.r-project.org/web/packages/BLCOP/vignettes/BLCOP.pdf\n# http://math.stackexchange.com/questions/17776/inverse-of-the-sum-of-matrices\ndef risk_parity_obj(params, sigma, target):\n    \n    risk = np.sqrt(np.matmul(np.transpose(params), np.matmul(sigma, params)))\n    risk_contrib = target / len(params)\n    \n    result = -(sum(np.log(params)) - (1 / risk_contrib) * (risk - target))\n    \n    return result\n\ndef risk_parity_optim(params, sigma, target):\n    \n    result = minimize(risk_parity_obj, params, args = (sigma, target)).x\n    result = result / sum(result) # no leverage\n    \n    return result\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ntarget = 1\nstart = np.array([1] * len(factors))\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nparams5 = risk_parity_optim(start, sigma, target)\nparams5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.03001117, 0.13139588, 0.57725273, 0.26134022])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nrisk = np.sqrt(np.matmul(np.transpose(params5), np.matmul(sigma, params5)))\nrisk_contrib = np.multiply(params5, np.matmul(sigma, params5)) / risk\nrisk_contrib\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([0.00239932, 0.00239926, 0.00239922, 0.0023993 ])\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.matmul(mu, params5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.003968692809216631\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.sqrt(np.matmul(np.transpose(params5), np.matmul(sigma, params5))) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.009597094428203801\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npd.DataFrame.from_dict({\"max_pnl\": params1,\n                        \"min_risk\": params2,\n                        \"max_ratio\": params3,\n                        \"black_litterman\": params4,\n                        \"risk_parity\": params5})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        max_pnl  min_risk     max_ratio  black_litterman  risk_parity\n0  4.375392e-01  0.285822  4.344722e-01         0.886595     0.030011\n1  5.624608e-01  0.549108  5.655278e-01         0.039994     0.131396\n2  2.220446e-16  0.108055  2.220446e-16         0.053728     0.577253\n3  2.220446e-16  0.057014  3.040103e-16         0.019683     0.261340\n```\n:::\n:::\n\n\n## Portfolio attribution\n\n### Single-period\n\nThe arithmetic active return is commonly decomposed using the Brinson-Fachler method:\n\n$$\n\\begin{aligned}\n\\text{Allocation: } &r_{a}=\\sum_{k=1}^{n}(w_{p,k}-w_{b,k})(r_{b,k}-r_{b})\\\\\n\\text{Selection: } &r_{s}=\\sum_{k=1}^{n}w_{p,k}(r_{p,k}-r_{b,k})\\\\\n\\end{aligned}\n$$\n\nwhere $k=1,\\ldots,n$ is each sector or factor.\n\n### Multi-period\n\nArithmetic attributes add to the active return of a single period; however, they cannot be summed or compounded to explain the active return over multiple periods. To solve this problem, the original arithmetic attribute is multiplied by a single scaling coefficient for that period. After all single-period original attributes have been transformed, the adjusted attributes sum to the active return over the periods.\n\n$$\n\\begin{aligned}\n\\text{Carino scaling coefficient: } &c_{t}=\\frac{[\\ln(1+r_{p,t})-\\ln(1+r_{b,t})]/(r_{p,t}-r_{b,t})}{[\\ln(1+r_{p})-\\ln(1+r_{b})]/(r_{p}-r_{b})}\n\\end{aligned}\n$$\n\nwhere $t=1,\\ldots,n$ is each period.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# http://www.frongello.com/support/Works/Chap20RiskBook.pdf\n# https://github.com/R-Finance/PortfolioAttribution/blob/master/R/Carino.R\ndef pnl_attrib(params, x):\n    \n    total_i = np.sum(x, axis = 1)\n    total = np.prod(1 + total_i) - 1\n    \n    coef = (np.log(1 + total_i) / total_i) / (np.log(1 + total) / total)\n    \n    result = np.sum(np.multiply(x, coef), axis = 0)\n    \n    return np.ravel(result)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nattrib_mat = np.multiply(params4, np.matrix(returns_x_df)[-width:])\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npnl_attrib(params4, attrib_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 2.05769409e-01, -3.05548073e-03, -9.99306361e-05,  2.08244498e-04])\n```\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}