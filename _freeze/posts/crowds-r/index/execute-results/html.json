{
  "hash": "c22328a7dbb3e8ef06a55d6a72edcb82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Crowds\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - r\ndraft: true\neditor: \n  mode: source\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_r <- c(\"SP500\") # \"SP500\" does not contain dividends\nfactors_d <- c(\"DTB3\")\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n# Parse web\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(yfscreen)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilters <- list(\"eq\", list(\"categoryname\", \"Tactical Allocation\"))\nquery <- create_query(filters)\npayload <- create_payload(\"mutualfund\", query, 250)\ndata <- get_data(payload)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsorted_df <- data[order(\n  -data[[\"netAssets.raw\"]],\n  data[[\"netExpenseRatio.raw\"]],\n  data[[\"firstTradeDateMilliseconds\"]],\n  data[[\"longName\"]],\n  data[[\"symbol\"]]\n), ]\ntickers <- sorted_df[!duplicated(sorted_df[[\"netAssets.raw\"]]), \"symbol\"]\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# allocations <- c(\"AOK\", \"AOM\", \"AOR\", \"AOA\")\n# tickers <- c(tickers, allocations)\n```\n:::\n\n\n# Optimization\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"devtools\")\n# devtools::install_github(\"jasonjfoster/rolloptim\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# library(CVXR)\nlibrary(rolloptim)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# min_rss_optim <- function(x, y) {\n#     \n#     params <- Variable(ncol(x))\n#     \n#     obj <- Minimize(sum_squares(y - x %*% params))\n#     \n#     cons <- list(sum(params) == 1, params >= 0, params <= 1)\n#     \n#     prob <- Problem(obj, cons)\n#         \n#     result <- solve(prob)$getValue(params)\n#     \n#     return(result)\n# \n# }\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperformance_xts <- roll_prod(1 + returns_xts, width, min_obs = 1) - 1\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_rows <- nrow(overlap_xts)\nresult_ls <- list()\nindex_ls <- list()\n\n# for (i in width:n_rows) {\nfor (i in n_rows) {\n    \n  idx <- max(i - width + 1, 1):i\n  x_subset <- coredata(overlap_x_xts[idx, ])\n  y_subset <- coredata(overlap_y_xts[idx, ])\n  params_ls <- list()\n  tickers_ls <- list()\n  performance_ls <- list()\n  \n  # for (j in tickers[!tickers %in% allocations]) {\n  for (j in tickers) {\n    \n    idx <- complete.cases(x_subset, y_subset[ , j])\n    x_complete <- x_subset[idx, , drop = FALSE]\n    y_complete <- y_subset[idx, j]\n    \n    if ((nrow(x_complete) > 0) && (length(y_complete) > 0)) {\n        \n      # params <- t(min_rss_optim(x_complete, y_complete))\n      # params_ls <- append(params_ls, list(params))\n    \n      xx <- roll_crossprod(x_complete, x_complete, width = nrow(x_complete))\n      xy <- roll_crossprod(x_complete, y_complete, width = nrow(x_complete))\n      \n      params <- roll_min_rss(xx, xy, total = 1, lower = 0, upper = 1)[nrow(x_complete), ]\n      params_ls <- append(params_ls, list(params))\n      \n      tickers_ls <- append(tickers_ls, list(j))\n      \n      performance_ls <- append(performance_ls, list(performance_xts[i, j]))\n        \n    }\n      \n  }\n  \n  if (length(params_ls) > 0) {\n      \n    result <- do.call(rbind, params_ls)\n    rownames(result) <- unlist(tickers_ls)\n    \n    result <- cbind(result, performance = unlist(performance_ls))\n    \n    result_ls <- append(result_ls, list(result))\n    index_ls <- append(index_ls, list(index(overlap_xts)[i]))\n      \n  }\n  \n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save(result_ls, file = \"result_ls.rda\")\n# save(index_ls, file = \"index_ls.rda\")\n```\n:::\n\n\n# Performance\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load(\"result_ls.rda\")\n# load(\"index_ls.rda\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile_cut <- function(x) {\n  \n  result <- cut(\n    -x,\n    breaks = quantile(-x, probs = c(0, 0.25, 0.5, 0.75, 1)),\n    labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\"),\n    include.lowest = TRUE\n  )\n  \n  return(result)\n  \n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_rows <- length(result_ls)\nscore_ls <- list()\n\nfor (i in 1:n_rows) {\n  \n  score_df <- data.frame(result_ls[[i]])\n  colnames(score_df) <- c(factors, \"performance\")\n  \n  score_df[[\"date\"]] <- index_ls[[i]]\n  score_df[[\"quantile\"]] <- quantile_cut(score_df[[\"performance\"]])\n  \n  score <- aggregate(\n    cbind(weight = get(factors[1]), performance) ~ date + quantile,\n    score_df, mean\n  )\n  \n  overall <- data.frame(\n    date = index_ls[[i]],\n    quantile = \"Overall\",\n    weight = mean(score_df[[factors[1]]]),\n    performance = mean(score_df[[\"performance\"]])\n  )\n  \n  score <- rbind(score, overall)\n  \n  score_ls <- append(score_ls, list(score))\n  \n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscore_df <- do.call(rbind, score_ls)\nprint(score_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        date quantile    weight performance\n1 2025-09-24       Q1 0.9015772  0.09617225\n2 2025-09-24       Q2 0.8003992  0.06850318\n3 2025-09-24       Q3 0.5673323  0.05309431\n4 2025-09-24       Q4 0.2578193  0.02670092\n5 2025-09-24  Overall 0.6317820  0.06111766\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save(score_df, file = \"score_df.rda\")\n# score_xts <- xts(score_df[score_df[[\"quantile\"]] == \"Q1\", \"weight\"],\n#                  score_df[score_df[[\"quantile\"]] == \"Q1\", \"date\"])\n# plot(score_xts)\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}