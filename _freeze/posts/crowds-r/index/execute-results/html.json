{
  "hash": "9870db225943b24a83cd65da7c7cc905",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Crowds\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - r\ndraft: true\neditor: \n  mode: source\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_r <- c(\"SP500\") # \"SP500\" does not contain dividends\nfactors_d <- c(\"DTB3\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n# Parse web\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprocess_filter <- function(filter) {\n\n  result <- list(\n    operator = filter[[1]],\n    operands = lapply(filter[[2]], function(operand) {\n      if (is.list(operand)) {\n        process_filter(operand)\n      } else {\n        operand\n      }\n    })\n  )\n\n  return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_query <- function(filters = list(list(\"or\", list(list(\"eq\", list(\"region\", \"us\"))))),\n                         top_operator = \"and\") {\n\n  result <- list(\n    operator = top_operator,\n    operands = lapply(filters, process_filter)\n  )\n\n  return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_payload <- function(quote_type = \"equity\", query = create_query(),\n                           size = 25, offset = 0,\n                           sort_field = NULL, sort_type = NULL,\n                           top_operator = \"and\") {\n\n  result <- list(\n    includeFields = NULL, # unable to modify the result\n    offset = offset,\n    query = query,\n    quoteType = quote_type,\n    size = size,\n    sortField = sort_field,\n    sortType = sort_type,\n    topOperator = top_operator\n  )\n\n  return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_session <- function() {\n\n  handle <- curl::new_handle()\n\n  api_url <- \"https://query1.finance.yahoo.com/v1/test/getcrumb\"\n\n  headers <- c(\n    `Accept` = \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n    `User-Agent` = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36\"\n  )\n\n  curl::handle_setheaders(handle, .list = headers)\n\n  response <- curl::curl_fetch_memory(api_url, handle = handle)\n  crumb <- rawToChar(response$content)\n\n  cookies <- curl::handle_cookies(handle)\n\n  result <- list(\n    handle = handle,\n    crumb = crumb,\n    cookies = cookies\n  )\n\n  return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbuild_query_string <- function(params) {\n  paste0(\"?\", paste(names(params), params, sep = \"=\", collapse = \"&\"))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_screen <- function(payload = create_payload()) {\n\n  session <- get_session()\n\n  crumb <- session[[\"crumb\"]]\n  cookies <- session[[\"cookies\"]]\n  handle <- session[[\"handle\"]]\n\n  params <- list(\n    crumb = crumb,\n    lang = \"en-US\",\n    region = \"US\",\n    formatted = \"true\",\n    corsDomain = \"finance.yahoo.com\"\n  )\n\n  api_url <- paste0(\"https://query1.finance.yahoo.com/v1/finance/screener\", build_query_string(params))\n\n  json_payload <- jsonlite::toJSON(payload, auto_unbox = TRUE)\n  \n  headers <- c(\n    `Content-Type` = \"application/json\",\n    `Cookie` = paste0(cookies[[\"name\"]], \"=\", cookies[[\"value\"]], collapse = \"; \")\n  )\n\n  max_size <- 250\n  size <- payload[[\"size\"]]\n  offset <- payload[[\"offset\"]]\n\n  result_cols <- NULL\n  result_ls <- list()\n\n  while (size > 0) {\n\n    chunk_size <- min(size, max_size)\n    payload[[\"size\"]] <- chunk_size\n    payload[[\"offset\"]] <- offset\n\n    json_payload <- jsonlite::toJSON(payload, auto_unbox = TRUE)\n\n    curl::handle_setopt(handle, postfields = json_payload)\n    curl::handle_setheaders(handle, .list = headers)\n\n    response <- curl::curl(api_url, handle = handle)\n\n    result <- jsonlite::fromJSON(response)\n    result_df <- result[[\"finance\"]][[\"result\"]][[\"quotes\"]][[1]]\n\n    if (!is.null(result_df)) {\n\n      result_df <- jsonlite::flatten(result_df)\n\n      result_ls <- append(result_ls, list(result_df))\n      result_cols <- union(result_cols, colnames(result_df))\n\n      offset <- offset + chunk_size\n      size <- size - chunk_size\n\n    } else {\n      size <- 0\n    }\n\n  }\n\n  result_ls <- lapply(result_ls, function(x) {\n\n    cols_na <- setdiff(result_cols, colnames(x))\n\n    for (j in cols_na) {\n      x[[j]] <- NA\n    }\n\n    x <- x[ , result_cols]\n\n  })\n\n  result <- do.call(rbind, result_ls)\n\n  return(result)\n\n}\n```\n:::\n\n\n# Optimization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(CVXR)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_rss_optim <- function(x, y) {\n    \n    params <- Variable(ncol(x))\n    \n    obj <- Minimize(sum_squares(y - x %*% params))\n    \n    cons <- list(sum(params) == 1, params >= 0, params <= 1)\n    \n    prob <- Problem(obj, cons)\n        \n    result <- solve(prob)$getValue(params)\n    \n    return(result)\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilters <- list(list(\"or\", list(list(\"eq\", list(\"categoryname\", \"Tactical Allocation\")))))\nquery <- create_query(filters)\npayload <- create_payload(quote_type = \"mutualfund\", query = query, size = 250, \n                          sort_field = \"fundnetassets\")\nscreen <- get_screen(payload)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsorted_df <- screen[order(screen[[\"netAssets.raw\"]], screen[[\"firstTradeDateMilliseconds\"]]), ]\ntickers <- sorted_df[!duplicated(sorted_df[[\"netAssets.raw\"]]), \"symbol\"]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# allocations <- c(\"AOK\", \"AOM\", \"AOR\", \"AOA\")\n# tickers <- c(tickers, allocations)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nperformance_xts <- roll_prod(1 + returns_xts, width, min_obs = 1) - 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_rows <- nrow(overlap_xts)\nresult_ls <- list()\nindex_ls <- list()\n\n# for (i in width:n_rows) {\nfor (i in n_rows) {\n    \n    idx <- max(i - width + 1, 1):i\n    x_subset <- coredata(overlap_x_xts[idx, ])\n    y_subset <- coredata(overlap_y_xts[idx, ])\n    params_ls <- list()\n    tickers_ls <- list()\n    performance_ls <- list()\n    \n    # for (j in tickers[!tickers %in% allocations]) {\n    for (j in tickers) {\n      \n        idx <- complete.cases(x_subset, y_subset[ , j])\n        x_complete <- x_subset[idx, , drop = FALSE]\n        y_complete <- y_subset[idx, j]\n        \n        if ((nrow(x_complete) > 0) && (length(y_complete) > 0)) {\n            \n            params <- t(min_rss_optim(x_complete, y_complete))\n            params_ls <- append(params_ls, list(params))\n            \n            tickers_ls <- append(tickers_ls, list(j))\n            \n            performance_ls <- append(performance_ls, list(performance_xts[i, j]))\n            \n        }\n        \n    }\n    \n    if (length(params_ls) > 0) {\n        \n        result <- do.call(rbind, params_ls)\n        rownames(result) <- unlist(tickers_ls)\n        \n        result <- cbind(result, performance = unlist(performance_ls))\n        \n        result_ls <- append(result_ls, list(result))\n        index_ls <- append(index_ls, list(index(overlap_xts)[i]))\n        \n    }\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# save(result_ls, file = \"result_ls.rda\")\n# save(index_ls, file = \"index_ls.rda\")\n```\n:::\n\n\n# Performance\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load(\"result_ls.rda\")\n# load(\"index_ls.rda\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile_cut <- function(x) {\n  \n  result <- cut(\n    -x,\n    breaks = quantile(-x, probs = c(0, 0.25, 0.5, 0.75, 1)),\n    labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\"),\n    include.lowest = TRUE\n  )\n  \n  return(result)\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_rows <- length(result_ls)\nscore_ls <- list()\n\nfor (i in 1:n_rows) {\n  \n  score_df <- data.frame(result_ls[[i]])\n  colnames(score_df) <- c(factors, \"performance\")\n  \n  score_df[[\"date\"]] <- index_ls[[i]]\n  score_df[[\"quantile\"]] <- quantile_cut(score_df[[\"performance\"]])\n  \n  score <- aggregate(\n    cbind(weight = get(factors[1]), performance) ~ date + quantile,\n    score_df, mean\n  )\n  \n  overall <- data.frame(\n    date = index_ls[[i]],\n    quantile = \"Overall\",\n    weight = mean(score_df[[factors[1]]]),\n    performance = mean(score_df[[\"performance\"]])\n  )\n  \n  score <- rbind(score, overall)\n  \n  score_ls <- append(score_ls, list(score))\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(rbind, score_ls)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        date quantile    weight performance\n1 2025-04-09       Q1 0.2351677 -0.02596310\n2 2025-04-09       Q2 0.5407590 -0.07515537\n3 2025-04-09       Q3 0.6751517 -0.10858365\n4 2025-04-09       Q4 0.9075384 -0.18569736\n5 2025-04-09  Overall 0.5892078 -0.09902012\n```\n\n\n:::\n\n```{.r .cell-code}\n# score_xts <- do.call(rbind, score_ls)\n# score_xts <- xts(score_xts[score_xts[[\"quantile\"]] == \"Q1\", \"weight\"],\n#                  score_xts[score_xts[[\"quantile\"]] == \"Q1\", \"date\"])\n# plot(score_xts)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}