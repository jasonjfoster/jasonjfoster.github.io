{
  "hash": "0f3821e45f56e5dee8c0e1e495ea5cab",
  "result": {
    "markdown": "---\ntitle: \"Securities\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - r\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(quantmod)\nlibrary(roll)\nlibrary(data.table)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfactors_r <- c(\"SP500\", \"DTWEXAFEGS\") # \"SP500\" does not contain dividends; note: \"DTWEXM\" discontinued as of Jan 2020\nfactors_d <- c(\"DGS10\", \"BAMLH0A0HYM2\")\nfactors <- c(factors_r, factors_d)\nwidth <- 252\nscale <- list(\"periods\" = 252, \"overlap\" = 5)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngetSymbols(factors, src = \"FRED\")\nlevels_xts <- do.call(merge, c(lapply(factors, function(i) get(i)), all = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreturns_xts <- do.call(merge, lapply(factors, function(i) {\n    if (i %in% factors_r) {\n        diff(log((levels_xts[ , i])))\n    } else if (i %in% factors_d) {\n        -diff(levels_xts[ , i]) / 100\n    }    \n}))\noverlap_xts <- roll_mean(returns_xts, scale[[\"overlap\"]], min_obs = 1, na_restore = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsd_xts <- roll_sd(overlap_xts, width, min_obs = 1) * sqrt(scale[[\"periods\"]]) * sqrt(scale[[\"overlap\"]])\n```\n:::\n\n\n# Black-Scholes model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevel_shock <- function(shock, S, tau, sigma) {\n    \n    result <- S * (1 + shock * sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n```\n:::\n\n\n-   <https://en.wikipedia.org/wiki/Greeks_(finance)>\n-   <https://www.wolframalpha.com/input/?i=option+pricing+formula>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor <- \"SP500\"\ntypes <- c(\"call\", \"put\")\nS <- coredata(na.locf(levels_xts[nrow(levels_xts), factor]))\nK <- S\nr <- 0 # use \"USD3MTD156N\"\nq <- 0 # see https://stackoverflow.com/a/11286679 \ntau <- 1 # = 252 / 252\nsigma <- coredata(sd_xts[nrow(sd_xts), factor]) # use \"VIXCLS\"\nshocks <- seq(-3, 3, by = 0.5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt <- CJ(type = types, shock = shocks)\ngreeks_dt[ , spot := level_shock(shock, S, tau, sigma), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n## Value\n\nFor a given spot price $S$, strike price $K$, risk-free rate $r$, annual dividend yield $q$, time-to-maturity $\\tau = T - t$, and volatility $\\sigma$:\n\n$$\n\\begin{aligned}\nV_{c}&=Se^{-q\\tau}\\Phi(d_{1})-e^{-r\\tau}K\\Phi(d_{2}) \\\\\nV_{p}&=e^{-r\\tau}K\\Phi(-d_{2})-Se^{-q\\tau}\\Phi(-d_{1})\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_value <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n  \n    r_df <- exp(-r * tau)\n    q_df <- exp(-q * tau)\n    \n    call_value <- S * q_df * Phi(d1) - r_df * K * Phi(d2)\n    put_value <- r_df * K * Phi(-d2) - S * q_df * Phi(-d1)\n    result <- ifelse(type == \"call\", call_value, put_value)\n    \n    return(result)\n    \n} \n```\n:::\n\n\nwhere\n\n$$\n\\begin{aligned}\nd_{1}&={\\frac{\\ln(S/K)+(r-q+\\sigma^{2}/2)\\tau}{\\sigma{\\sqrt{\\tau}}}} \\\\\nd_{2}&={\\frac{\\ln(S/K)+(r-q-\\sigma^{2}/2)\\tau}{\\sigma{\\sqrt{\\tau}}}}=d_{1}-\\sigma{\\sqrt{\\tau}} \\\\\n\\phi(x)&={\\frac{e^{-{\\frac {x^{2}}{2}}}}{\\sqrt{2\\pi}}} \\\\\n\\Phi(x)&={\\frac{1}{\\sqrt{2\\pi}}}\\int_{-\\infty}^{x}e^{-{\\frac{y^{2}}{2}}}dy=1-{\\frac{1}{\\sqrt{2\\pi}}}\\int_{x}^{\\infty}e^{-{\\frac{y^{2}}{2}}dy}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_d1 <- function(S, K, r, q, tau, sigma) {\n    \n    result <- (log(S / K) + (r - q + sigma ^ 2 / 2) * tau) / (sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n\nbs_d2 <- function(S, K, r, q, tau, sigma) {\n    \n    result <- (log(S / K) + (r - q - sigma ^ 2 / 2) * tau) / (sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n\nphi <- function(x) {\n    \n    result <- dnorm(x)\n    \n    return(result)\n    \n}\n\nPhi <- function(x) {\n    \n    result <- pnorm(x)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , d1 := bs_d1(spot, K, r, q, tau, sigma), by = c(\"type\", \"shock\")]\ngreeks_dt[ , d2 := bs_d2(spot, K, r, q, tau, sigma), by = c(\"type\", \"shock\")]\ngreeks_dt[ , value := bs_value(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n## First-order\n\n### Delta\n\n$$\n\\begin{aligned}\n\\Delta_{c}&={\\frac{\\partial V_{c}}{\\partial S}}=e^{-q\\tau}\\Phi(d_{1}) \\\\\n\\Delta_{p}&={\\frac{\\partial V_{p}}{\\partial S}}=-e^{-q\\tau}\\Phi(-d_{1})\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_delta <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n    \n    q_df <- exp(-q * tau)\n  \n    call_value <- q_df * Phi(d1)\n    put_value <- -q_df * Phi(-d1)\n    result <- ifelse(type == \"call\", call_value, put_value)\n    \n    return(result)\n    \n} \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , delta := bs_delta(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n### Delta-beta\n\nNotional market value is the market value of a leveraged position:\n\n$$\n\\begin{aligned}\n\\text{Equity options }=&\\,\\#\\text{ contracts}\\times\\text{multiple}\\times\\text{spot price}\\\\\n\\text{Delta-adjusted }=&\\,\\#\\text{ contracts}\\times\\text{multiple}\\times\\text{spot price}\\times\\text{delta}\n\\end{aligned}\n$$\n\n-   <https://en.wikipedia.org/wiki/Notional_amount>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_delta_diff <- function(type, S, K, r, q, tau, sigma, delta0) {\n    \n    d1 <- bs_d1(S, K, r, q, tau, sigma)\n    d2 <- bs_d2(S, K, r, q, tau, sigma)\n    delta <- bs_delta(type, S, K, r, q, tau, sigma, d1, d2)\n    \n    call_value <- delta - delta0\n    put_value <- delta0 - delta\n    \n    result <- ifelse(type == \"call\", call_value, put_value)\n        \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta <- 0.35\ntype <- \"call\"\nn <- 1\nmultiple <- 100\ntotal <- 1000000\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- bs_d1(S, K, r, q, tau, sigma)\nd2 <- bs_d2(S, K, r, q, tau, sigma)\nsec <- list(\n    \"n\" = n,\n    \"multiple\" = multiple,\n    \"S\" = S,\n    \"delta\" = bs_delta(type, S, K, r, q, tau, sigma, d1, d2),\n    \"beta\" = 1\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta_dt <- CJ(type = type, shock = shocks)\nbeta_dt[ , spot := level_shock(shock, S, tau, sigma), by = c(\"type\", \"shock\")]\nbeta_dt[ , static := beta]\nbeta_dt[ , diff := bs_delta_diff(type, spot, K, r, q, tau, sigma, sec[[\"delta\"]])]\nbeta_dt[ , dynamic := beta + sec[[\"n\"]] * sec[[\"multiple\"]] * sec[[\"S\"]] * sec[[\"beta\"]] * diff / total, by = c(\"type\", \"shock\")]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=384}\n:::\n:::\n\n\nFor completeness, duration equivalent is defined as:\n\n$$\n\\begin{aligned}\n\\text{10-year equivalent }=\\,&\\frac{\\text{security duration}}{\\text{10-year OTR duration}}\n\\end{aligned}\n$$\n\n### Vega\n\n$$\n\\begin{aligned}\n\\nu_{c,p}&={\\frac{\\partial V_{c,p}}{\\partial\\sigma}}=Se^{-q\\tau}\\phi(d_{1}){\\sqrt{\\tau}}=Ke^{-r\\tau}\\phi(d_{2}){\\sqrt{\\tau}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_vega <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n    \n    q_df <- exp(-q * tau)\n    \n    result <- S * q_df * phi(d1) * sqrt(tau)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , vega := bs_vega(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n### Theta\n\n$$\n\\begin{aligned}\n\\Theta_{c}&=-{\\frac{\\partial V_{c}}{\\partial \\tau}}=-e^{-q\\tau}{\\frac{S\\phi(d_{1})\\sigma}{2{\\sqrt{\\tau}}}}-rKe^{-r\\tau}\\Phi(d_{2})+qSe^{-q\\tau}\\Phi(d_{1}) \\\\\n\\Theta_{p}&=-{\\frac{\\partial V_{p}}{\\partial \\tau}}=-e^{-q\\tau}{\\frac{S\\phi(d_{1})\\sigma}{2{\\sqrt{\\tau}}}}+rKe^{-r\\tau}\\Phi(-d_{2})-qSe^{-q\\tau}\\Phi(-d_{1})\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_theta <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n    \n    r_df <- exp(r * tau)\n    q_df <- exp(q * tau)\n  \n    call_value <- -q_df * S * phi(d1) * sigma / (2 * sqrt(tau)) -\n      r * K * r_df * Phi(d2) + q * S * q_df * Phi(d1)\n    \n    put_value <- -q_df * S * phi(d1) * sigma / (2 * sqrt(tau)) +\n      r * K * r_df * Phi(-d2) - q * S * q_df * Phi(-d1)\n        \n    result <- ifelse(type == \"call\", call_value, put_value)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , theta := bs_theta(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n## Second-order\n\n### Gamma\n\n$$\n\\begin{aligned}\n\\Gamma_{c,p}&={\\frac{\\partial\\Delta_{c,p}}{\\partial S}}={\\frac{\\partial^{2}V_{c,p}}{\\partial S^{2}}}=e^{-q\\tau}{\\frac{\\phi(d_{1})}{S\\sigma{\\sqrt{\\tau}}}}=Ke^{-r\\tau}{\\frac{\\phi(d_{2})}{S^{2}\\sigma{\\sqrt{\\tau}}}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_gamma <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n  \n    q_df <- exp(-q * tau)\n    \n    result <- q_df * phi(d1) / (S * sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , gamma := bs_gamma(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=960}\n:::\n:::\n\n\n# Taylor series\n\n## First-order\n\n### Price-yield formula\n\nFor a function of one variable, $f(x)$, the Taylor series formula is:\n\n$$\n\\begin{aligned}\nf(x+\\Delta x)&=f(x)+{\\frac{f'(x)}{1!}}\\Delta x+{\\frac{f''(x)}{2!}}(\\Delta x)^{2}+{\\frac{f^{(3)}(x)}{3!}}(\\Delta x)^{3}+\\cdots+{\\frac{f^{(n)}(x)}{n!}}(\\Delta x)^{n}+\\cdots\\\\\nf(x+\\Delta x)-f(x)&={\\frac{f'(x)}{1!}}\\Delta x+{\\frac{f''(x)}{2!}}(\\Delta x)^{2}+{\\frac{f^{(3)}(x)}{3!}}(\\Delta x)^{3}+\\cdots+{\\frac{f^{(n)}(x)}{n!}}(\\Delta x)^{n}+\\cdots\n\\end{aligned}\n$$\n\nUsing the price-yield formula, the estimated percentage change in price for a change in yield is:\n\n$$\n\\begin{aligned}\nP(y+\\Delta y)-P(y)&\\approx{\\frac{P'(y)}{1!}}\\Delta y+{\\frac{P''(y)}{2!}}(\\Delta y)^{2}\\\\\n&\\approx -D\\Delta y +{\\frac{C}{2!}}(\\Delta y)^{2}\n\\end{aligned}\n$$\n\nBecause of market conventions, use the following formula: $P(y+\\Delta y)-P(y)\\approx -D\\Delta y +{\\frac{C\\times 100}{2!}}(\\Delta y)^{2}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnl_bond <- function(duration, convexity, dy) {\n    \n    duration_pnl <- -duration * dy\n    convexity_pnl <- (convexity * 100 / 2) * dy ^ 2\n    income_pnl <- dy\n    \n    result <- list(\"total\" = duration_pnl + convexity_pnl + income_pnl,\n                   \"duration\" = duration_pnl,\n                   \"convexity\" = convexity_pnl,\n                   \"income\" = income_pnl)\n    \n    return(result)\n    \n} \n```\n:::\n\n\n-   <https://engineering.nyu.edu/sites/default/files/2021-07/CarWuRF2021.pdf>\n-   <https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118267967.app1>\n-   <https://www.investopedia.com/terms/c/convexity-adjustment.asp>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor <- \"DGS10\"\nduration <- 6.5\nconvexity <- 0.65\ny <- coredata(tail(na.locf(levels_xts[ , factor]), width)[1])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbonds_dt <- data.table(index = index(tail(levels_xts, width)),\n                       duration = duration, convexity = convexity,\n                       dy = na.locf(tail(levels_xts[ , factor], width)))\nsetnames(bonds_dt, c(\"index\", \"duration\", \"convexity\", \"dy\"))\nbonds_dt[ , dy := (dy - y) / 100, by = index]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattrib_dt <- bonds_dt[ , as.list(unlist(pnl_bond(duration, convexity, dy))), by = index]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=576}\n:::\n:::\n\n\n### Duration-yield formula\n\nThe derivative of duration with respect to interest rates gives:\n\n$$\n\\begin{aligned}\n\\text{Drift}&=-\\frac{\\partial D}{\\partial y}\\\\\n&=\\frac{1}{P}\\frac{\\partial^{2}P}{\\partial y^{2}}-\\frac{1}{P^{2}}\\frac{\\partial P}{\\partial y}\\frac{\\partial P}{\\partial y}\\\\\n&=C-D^{2}\n\\end{aligned}\n$$\n\nBecause of market conventions, use the following formula: $\\text{Drift}=\\frac{1}{100}\\left(C\\times 100-D^{2}\\right)=C-\\frac{D^{2}}{100}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyield_shock <- function(shock, tau, sigma) {\n    \n    result <- shock * sigma * sqrt(tau)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nduration_drift <- function(duration, convexity, dy) {\n    \n    drift <- convexity - duration ^ 2 / 100\n    change <- -drift * dy * 100\n    \n    result <- list(\"drift\" = drift,\n                   \"change\" = change)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# \"Risk Management: Approaches for Fixed Income Markets\" (page 45)\nfactor <- \"DGS10\"\nsigma <- coredata(sd_xts[nrow(sd_xts), factor])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nduration_dt <- CJ(shock = shocks)\nduration_dt[ , spot := yield_shock(shock, tau, sigma), by = \"shock\"]\nduration_dt[ , static := duration]\nduration_dt[ , dynamic := duration + duration_drift(duration, convexity, spot)[[\"change\"]], by = \"shock\"]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=384}\n:::\n:::\n\n\n## Second-order\n\n### Black's formula\n\nA similar formula holds for functions of several variables $f(x_{1},\\ldots,x_{n})$. This is usually written as:\n\n$$\n\\begin{aligned}\nf(x_{1}+\\Delta x_{1},\\ldots,x_{n}+\\Delta x_{n})&=f(x_{1},\\ldots, x_{n})+ \\sum _{j=1}^{n}{\\frac{\\partial f(x_{1},\\ldots,x_{n})}{\\partial x_{j}}}(\\Delta x_{j})\\\\\n&+{\\frac {1}{2!}}\\sum_{j=1}^{n}\\sum_{k=1}^{n}{\\frac{\\partial^{2}f(x_{1},\\ldots,x_{d})}{\\partial x_{j}\\partial x_{k}}}(\\Delta x_{j})(\\Delta x_{k})+\\cdots\n\\end{aligned}\n$$\n\nUsing Black's formula, the estimated change of an option price is:\n\n$$\n\\begin{aligned}\nV(S+\\Delta S,\\sigma+\\Delta\\sigma,t+\\Delta t)-V(S,\\sigma,t)&\\approx{\\frac{\\partial V}{\\partial S}}\\Delta S+{\\frac{1}{2!}}{\\frac{\\partial^{2}V}{\\partial S^{2}}}(\\Delta S)^{2}+{\\frac{\\partial V}{\\partial \\sigma}}\\Delta\\sigma+{\\frac{\\partial V}{\\partial t}}\\Delta t\\\\\n&\\approx \\Delta_{c,p}\\Delta S+{\\frac{1}{2!}}\\Gamma_{c,p}(\\Delta S)^{2}+\\nu_{c,p}\\Delta\\sigma+\\Theta_{c,p}\\Delta t\n\\end{aligned}\n$$\n\n-   <https://quant-next.com/option-greeks-and-pl-decomposition-part-1/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnl_option <- function(type, S, K, r, q, tau, sigma, dS, dt, dsigma) {\n    \n    d1 <- bs_d1(S, K, r, q, tau, sigma)\n    d2 <- bs_d2(S, K, r, q, tau, sigma)\n    value <- bs_value(type, S, K, r, q, tau, sigma, d1, d2)\n    delta <- bs_delta(type, S, K, r, q, tau, sigma, d1, d2)\n    vega <- bs_vega(type, S, K, r, q, tau, sigma, d1, d2)\n    theta <- bs_theta(type, S, K, r, q, tau, sigma, d1, d2)\n    gamma <- bs_gamma(type, S, K, r, q, tau, sigma, d1, d2)\n    \n    delta_pnl <- delta * dS / value\n    gamma_pnl <- gamma / 2 * dS ^ 2 / value\n    vega_pnl <- vega * dsigma / value\n    theta_pnl <- theta * dt / value\n    \n    result <- list(\"total\" = delta_pnl + gamma_pnl + vega_pnl + theta_pnl,\n                   \"delta\" = delta_pnl,\n                   \"gamma\" = gamma_pnl,\n                   \"vega\" = vega_pnl,\n                   \"theta\" = theta_pnl)\n    \n    return(result)    \n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor <- \"SP500\"\ntype <- \"call\"\nS <- coredata(tail(na.locf(levels_xts[ , factor]), width)[1])\nK <- S # * (1 + 0.05)\ntau <- 1 # = 252 / 252\nsigma <- coredata(tail(sd_xts[ , factor], width)[1])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noptions_dt <- data.table(index = index(tail(levels_xts, width)),\n                         spot = na.locf(tail(levels_xts[ , factor], width)),\n                         sigma = tail(sd_xts[ , factor], width))\nsetnames(options_dt, c(\"index\", \"spot\", \"sigma\"))\noptions_dt[ , dS := spot - S, by = index]\noptions_dt[ , dt_diff := as.numeric(index - index[1])]\noptions_dt[ , dt := dt_diff / tail(dt_diff, 1)]\noptions_dt[ , dsigma := sigma - ..sigma, by = index]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattrib_dt <- options_dt[ , as.list(unlist(pnl_option(type, S, K, r, q, tau, ..sigma,\n                                                     dS, dt, dsigma))), by = index]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-43-1.png){width=576}\n:::\n:::\n\n\n### Ito's lemma\n\nFor a given diffiusion $X(t, w)$ driven by:\n\n$$\n\\begin{aligned}\ndX_{t}&=\\mu_{t}dt+\\sigma_{t}dB_{t}\n\\end{aligned}\n$$\n\nThen proceed with the Taylor series for a function of two variables $f(t,x)$:\n\n$$\n\\begin{aligned}\ndf&={\\frac{\\partial f}{\\partial t}}dt+{\\frac{\\partial f}{\\partial x}}dx+{\\frac{1}{2}}{\\frac{\\partial^{2}f}{\\partial x^{2}}}dx^{2}\\\\\n&={\\frac{\\partial f}{\\partial t}}dt+{\\frac{\\partial f}{\\partial x}}(\\mu_{t}dt+\\sigma_{t}dB_{t})+{\\frac{1}{2}}{\\frac{\\partial^{2}f}{\\partial x^{2}}}\\left(\\mu_{t}^{2}dt^{2}+2\\mu_{t}\\sigma _{t}dtdB_{t}+\\sigma_{t}^{2}dB_{t}^{2}\\right)\\\\\n&=\\left({\\frac{\\partial f}{\\partial t}}+\\mu_{t}{\\frac{\\partial f}{\\partial x}}+{\\frac{\\sigma _{t}^{2}}{2}}{\\frac{\\partial ^{2}f}{\\partial x^{2}}}\\right)dt+\\sigma_{t}{\\frac{\\partial f}{\\partial x}}dB_{t}\n\\end{aligned}\n$$\n\nNote: set the $dt^{2}$ and $dtdB_{t}$ terms to zero and substitute $dt$ for $dB^{2}$.\n\n### Geometric Brownian motion\n\nThe most common application of Ito's lemma in finance is to start with the percent change of an asset:\n\n$$\n\\begin{aligned}\n\\frac{dS}{S}&=\\mu_{t}dt+\\sigma_{t}dB_{t}\n\\end{aligned}\n$$\n\nThen apply Ito's lemma with $f(S)=log(S)$:\n\n$$\n\\begin{aligned}\nd\\log(S)&=f^{\\prime}(S)dS+{\\frac{1}{2}}f^{\\prime\\prime}(S)S^{2}\\sigma^{2}dt\\\\\n&={\\frac {1}{S}}\\left(\\sigma SdB+\\mu Sdt\\right)-{\\frac{1}{2}}\\sigma^{2}dt\\\\\n&=\\sigma dB+\\left(\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right)dt\n\\end{aligned}\n$$\n\nIt follows that:\n\n$$\n\\begin{aligned}\n\\log(S_{t})-\\log(S_{0})=\\sigma dB+\\left(\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right)dt\n\\end{aligned}\n$$\n\nExponentiating gives the expression for $S$:\n\n$$\n\\begin{aligned}\nS_{t}=S_{0}\\exp\\left(\\sigma B_{t}+\\left(\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right)t\\right)\n\\end{aligned}\n$$\n\nThis provides a recursive procedure for simulating values of $S$ at $t_{0}<t_{1}<\\cdots<t_{n}$:\n\n$$\n\\begin{aligned}\nS(t_{i+1})&=S(t_{i})\\exp\\left(\\sigma\\sqrt{t_{i+1}-t_{i}}Z_{i+1}+\\left[\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right]\\left(t_{i+1}-t_{i}\\right)\\right)\n\\end{aligned}\n$$\n\nwhere $Z_{1},Z_{2},\\ldots,Z_{n}$ are independent standard normals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_gbm <- function(n_sim, S, mu, sigma, dt) {\n    \n    result <- S * exp(cumsum(sigma * sqrt(dt) * rnorm(n_sim)) +\n                      (mu - 0.5 * sigma ^ 2) * dt)\n    \n    return(result)\n    \n}\n```\n:::\n\n\nThis leads to an algorithm for simulating a multidimensional geometric Brownian motion:\n\n$$\n\\begin{aligned}\nS_{k}(t_{i+1})&=S_{k}(t_{i})\\exp\\left(\\sqrt{t_{i+1}-t_{i}}\\sum_{j=1}^{d}{A_{kj}Z_{i+1,j}}+\\left[\\mu_{k}-{\\tfrac{\\sigma_{k}^{2}}{2}}\\right]\\left(t_{i+1}-t_{i}\\right)\\right)\n\\end{aligned}\n$$\n\nwhere $A$ is the Cholesky factor of $\\Sigma$, i.e. $A$ is any matrix for which $AA^\\mathrm{T}=\\Sigma$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_multi_gbm <- function(n_sim, S, mu, sigma, dt) {\n    \n    n_cols <- ncol(sigma)\n    \n    Z <- matrix(rnorm(n_sim * n_cols), nrow = n_sim, ncol = n_cols)\n    X <- sweep(sqrt(dt) * (Z %*% chol(sigma)), 2, (mu - 0.5 * diag(sigma)) * dt, \"+\")\n    \n    result <- sweep(apply(X, 2, function(x) exp(cumsum(x))), 2, S, \"*\")\n    \n    return(result)\n    \n}\n```\n:::\n\n\n-   <https://arxiv.org/pdf/0812.4210.pdf>\n-   <https://quant.stackexchange.com/questions/15219/calibration-of-a-gbm-what-should-dt-be>\n-   <https://stackoverflow.com/questions/36463227/geometrical-brownian-motion-simulation-in-r>\n-   <https://quant.stackexchange.com/questions/25219/simulate-correlated-geometric-brownian-motion-in-the-r-programming-language>\n-   <https://quant.stackexchange.com/questions/35194/estimating-the-historical-drift-and-volatility/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nS <- rep(1, length(factors))\nsigma <- cov(returns_xts, use = \"complete.obs\") * scale[[\"periods\"]]\nmu <- colMeans(na.omit(returns_xts)) * scale[[\"periods\"]]\nmu <- mu + diag(sigma) / 2 # drift\ndt <- 1 / scale[[\"periods\"]]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmu_ls <- list()\nsigma_ls <- list()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:1e4) {\n    \n    # assumes stock prices\n    levels_sim <- sim_multi_gbm(width + 1, S, mu, sigma, dt)\n    returns_sim <- diff(log(levels_sim))\n\n    mu_sim <- colMeans(returns_sim) * scale[[\"periods\"]]\n    sigma_sim <- apply(returns_sim, 2, sd) * sqrt(scale[[\"periods\"]])\n    \n    mu_ls <- append(mu_ls, list(mu_sim))\n    sigma_ls <- append(sigma_ls, list(sigma_sim))\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\"empirical\" = colMeans(na.omit(returns_xts)) * scale[[\"periods\"]],\n           \"theoretical\" = colMeans(do.call(rbind, mu_ls)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 empirical   theoretical\nSP500         0.0882574632  0.0909617990\nDTWEXAFEGS    0.0182866707  0.0179406059\nDGS10        -0.0005756897 -0.0006698148\nBAMLH0A0HYM2  0.0008581034  0.0011643750\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\"empirical\" = sqrt(diag(sigma)),\n           \"theoretical\" = colMeans(do.call(rbind, sigma_ls)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               empirical theoretical\nSP500        0.179653728 0.179471194\nDTWEXAFEGS   0.062198908 0.062108972\nDGS10        0.008224016 0.008218401\nBAMLH0A0HYM2 0.016932091 0.016915715\n```\n:::\n:::\n\n\n### Vasicek model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assumes interest rates follow mean-reverting process with stochastic volatility\n```\n:::\n\n\n# Newton's method\n\n## Implied volatility\n\nNewton's method (main idea is also from a Taylor series) is a method for finding approximations to the roots of a function $f(x)$:\n\n$$\n\\begin{aligned}\nx_{n+1}=x_{n}-{\\frac{f(x_{n})}{f'(x_{n})}}\n\\end{aligned}\n$$\n\nTo solve $V(\\sigma_{n})-V=0$ for $\\sigma_{n}$, use Newton's method and repeat until $\\left|\\sigma_{n+1}-\\sigma_{n}\\right|<\\varepsilon$:\n\n$$\n\\begin{aligned}\n\\sigma_{n+1}=\\sigma_{n}-{\\frac{V(\\sigma_{n})-V}{V'(\\sigma_{n})}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_newton <- function(params, type, S, K, r, q, tau) {\n    \n    target0 <- 0\n    sigma0 <- params[[\"sigma\"]]\n    \n    while (abs(target0 - params[[\"target\"]]) > params[[\"tol\"]]) {\n        \n        d1 <- bs_d1(S, K, r, q, tau, sigma0)\n        d2 <- bs_d2(S, K, r, q, tau, sigma0)\n        \n        target0 <- bs_value(type, S, K, r, q, tau, sigma0, d1, d2)\n        vega0 <- bs_vega(type, S, K, r, q, tau, sigma0, d1, d2)\n        \n        sigma <- sigma0 - (target0 - params[[\"target\"]]) / vega0\n        sigma0 <- sigma\n        \n    }\n    \n    return(sigma)\n    \n}\n```\n:::\n\n\n-   <http://www.aspenres.com/documents/help/userguide/help/bopthelp/bopt2Implied_Volatility_Formula.html>\n-   <https://books.google.com/books?id=VLi61POD61IC&pg=PA104>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nS <- coredata(na.locf(levels_xts)[nrow(levels_xts), factor])\nK <- S # * (1 + 0.05)\nsigma <- coredata(sd_xts[nrow(sd_xts), factor]) # overrides matrix\nstart <- 0.2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- bs_d1(S, K, r, q, tau, sigma)\nd2 <- bs_d2(S, K, r, q, tau, sigma)\ntarget <- bs_value(type, S, K, r, q, tau, sigma, d1, d2)\nparams <- list(\n    \"target\" = target,\n    \"sigma\" = start,\n    \"tol\" = 1e-4 # .Machine$double.eps\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_newton(params, type, S, K, r, q, tau)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         SP500\n[1,] 0.1341163\n```\n:::\n:::\n\n\n## Yield-to-maturity\n\n# Optimization\n\n## Implied volatility\n\nIf the derivative is unknown, try optimization:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_obj <- function(param, type, S, K, r, q, tau, target) {\n    \n    d1 <- bs_d1(S, K, r, q, tau, param)\n    d2 <- bs_d2(S, K, r, q, tau, param)\n    target0 <- bs_value(type, S, K, r, q, tau, param, d1, d2)\n    \n    result <- abs(target0 - target)\n    \n    return(result)\n    \n}\n\nimplied_vol_optim <- function(param, type, S, K, r, q, tau, target) {\n    \n    result <- optim(param, implied_vol_obj, type = type, S = S, K = K, r = r, q = q,\n                    tau = tau, target = target, method = \"Brent\", lower = 0, upper = 1)\n    \n    return(result$par)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_optim(start, type, S, K, r, q, tau, target)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1341163\n```\n:::\n:::\n\n\n## Yield-to-maturity\n\n<!-- ## Variance swaps -->\n\n<!-- A variance swap can be written as: -->\n\n<!-- $$ -->\n\n<!-- \\begin{aligned} -->\n\n<!-- K_{var}={\\frac{2e^{rT}}{T}}\\left(\\int\\limits_{0}^{F_{0}}{\\frac{1}{K^{2}}}P(K)dK+\\int\\limits_{F_{0}}^{\\infty}{\\frac{1}{K^{2}}} C(K)dK\\right) -->\n\n<!-- \\end{aligned} -->\n\n<!-- $$ -->\n\n<!-- The CBOE Volatility Index (VIX) is calculated as a variance swap on the 30-day variance of the S&P 500 with an adjustment term: -->\n\n<!-- $$ -->\n\n<!-- \\begin{aligned} -->\n\n<!-- \\sigma^{2}={\\frac{2e^{rT}}{T}}\\left(\\sum_{i=0}^{K_{0}}\\frac{\\Delta K_{i}}{K_{i}^{2}}P(K_{i})+\\sum_{i=K_{0}}^{\\infty}\\frac{\\Delta K_{i}}{K_{i}^{2}}C(K_{i})\\right)-\\frac{1}{T}\\left(\\frac{F}{K_{0}}-1\\right)^{2} -->\n\n<!-- \\end{aligned} -->\n\n<!-- $$ -->\n\n<!-- ```{r} -->\n\n<!-- # https://cdn.cboe.com/resources/vix/vixwhite.pdf -->\n\n<!-- # https://en.wikipedia.org/wiki/VIX -->\n\n<!-- # https://en.wikipedia.org/wiki/Variance_swap -->\n\n<!-- # https://www.ivolatility.com/doc/VarianceSwaps.pdf -->\n\n<!-- implied_vol_vix <- function(calls_df, puts_df, r, tau) { -->\n\n<!--   # time to expiration   -->\n\n<!--   t <- as.numeric(difftime(tau[[\"exp_time\"]], tau[[\"sys_time\"]], units = \"mins\")) / (365 * 24 * 60) -->\n\n<!--   # midpoint of bid and ask -->\n\n<!--   calls_df[[\"Mid\"]] <- rowMeans(calls_df[ , c(\"Bid\", \"Ask\")]) -->\n\n<!--   puts_df[[\"Mid\"]] <- rowMeans(puts_df[ , c(\"Bid\", \"Ask\")]) -->\n\n<!--   options_df <- merge(calls_df[ , c(\"Strike\", \"Mid\")], -->\n\n<!--                       puts_df[ , c(\"Strike\", \"Mid\")], by = \"Strike\") -->\n\n<!--   colnames(options_df) <- c(\"Strike\", \"Call\", \"Put\") -->\n\n<!--   options_df[[\"Diff\"]] <- abs(options_df[[\"Call\"]] - options_df[[\"Put\"]]) -->\n\n<!--   # minimum absolute difference is forward index level -->\n\n<!--   forward_df <- options_df[options_df[[\"Diff\"]] == min(options_df[[\"Diff\"]]), ] -->\n\n<!--   k <- forward_df[[\"Strike\"]] -->\n\n<!--   c <- forward_df[[\"Call\"]] -->\n\n<!--   p <- forward_df[[\"Put\"]] -->\n\n<!--   f <- k + exp(r * t) * (c - p) -->\n\n<!--   # strike price equal or below forward index level -->\n\n<!--   k0 <- tail(options_df[options_df[[\"Strike\"]] <= f, \"Strike\"], 1) -->\n\n<!--   # out-of-the-money options -->\n\n<!--   puts_otm_df <- puts_df[puts_df[[\"Strike\"]] < k0, ] -->\n\n<!--   calls_otm_df <- calls_df[calls_df[[\"Strike\"]] > k0, ] -->\n\n<!--   # stop after two consecutive strike prices with zero bid prices -->\n\n<!--   # https://stackoverflow.com/a/50311890 -->\n\n<!--   puts_otm_rle <- rle(puts_otm_df[[\"Bid\"]]) -->\n\n<!--   idx <- cumsum(puts_otm_rle$lengths) # end -->\n\n<!--   idx <- idx[max(which(puts_otm_rle$lengths > 1 & puts_otm_rle$values == 0))] -->\n\n<!--   puts_otm_df <- puts_otm_df[(idx + 1):nrow(puts_otm_df), ] -->\n\n<!--   calls_otm_rle <- rle(calls_otm_df[[\"Bid\"]]) -->\n\n<!--   idx <- cumsum(calls_otm_rle$lengths) # end -->\n\n<!--   idx <- idx - calls_otm_rle$lengths + 1 # start -->\n\n<!--   idx <- idx[max(which(calls_otm_rle$lengths > 1 & calls_otm_rle$values == 0))] -->\n\n<!--   calls_otm_df <- calls_otm_df[1:(idx - 1), ] -->\n\n<!--   # average put and call prices for k0 -->\n\n<!--   # note: exclude options with zero bid price -->\n\n<!--   result_df <- rbind(puts_otm_df[puts_otm_df[[\"Bid\"]] != 0, c(\"Strike\", \"Mid\")], -->\n\n<!--                      colMeans(rbind(puts_df[puts_df[[\"Strike\"]] == k0, c(\"Strike\", \"Mid\")], -->\n\n<!--                                     calls_df[calls_df[[\"Strike\"]] == k0, c(\"Strike\", \"Mid\")])), -->\n\n<!--                      calls_otm_df[calls_otm_df[[\"Bid\"]] != 0, c(\"Strike\", \"Mid\")]) -->\n\n<!--   # differences between strike prices -->\n\n<!--   n_rows <- nrow(result_df) -->\n\n<!--   result_df[1, \"Diff\"] <- result_df[2, \"Strike\"] - result_df[1, \"Strike\"] -->\n\n<!--   result_df[n_rows, \"Diff\"] <- result_df[n_rows, \"Strike\"] - result_df[n_rows - 1, \"Strike\"] -->\n\n<!--   result_df[2:(n_rows - 1), \"Diff\"] <- (result_df[3:n_rows, \"Strike\"] - -->\n\n<!--                                           result_df[1:(n_rows - 2), \"Strike\"]) / 2 -->\n\n<!--   # variance -->\n\n<!--   v <- sum(result_df[ , \"Diff\"] / result_df[ , \"Strike\"] ^ 2 * exp(r * t) * -->\n\n<!--              result_df[ , \"Mid\"]) * (2 / t) - (1 / t) * (f / k0 - 1) ^ 2 -->\n\n<!--   result <- list(\"t\" = t, -->\n\n<!--                  \"v\" = v) -->\n\n<!--   return(result) -->\n\n<!-- } -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n\n<!-- sys_time <- format(Sys.Date(), paste0(\"%Y-%m-%d\", \"09:46:00\")) -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n\n<!-- v1 <- implied_vol_vix(read.csv(\"../securities/near_calls.csv\"), read.csv(\"../securities/near_puts.csv\"), 0.000305, -->\n\n<!--                       list(\"sys_time\" = sys_time, -->\n\n<!--                            \"exp_time\" = format(Sys.Date() + 25, paste0(\"%Y-%m-%d\", \"08:30:00\")))) -->\n\n<!-- v2 <- implied_vol_vix(read.csv(\"../securities/next_calls.csv\"), read.csv(\"../securities/next_puts.csv\"), 0.000286, -->\n\n<!--                       list(\"sys_time\" = sys_time, -->\n\n<!--                            \"exp_time\" = format(Sys.Date() + 32, paste0(\"%Y-%m-%d\", \"15:00:00\")))) -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n\n<!-- nt1 <- v1$t * (365 * 24 * 60) -->\n\n<!-- nt2 <- v2$t * (365 * 24 * 60) -->\n\n<!-- n30 <- 30 * (24 * 60) -->\n\n<!-- n365 <- 365 * (24 * 60) -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n\n<!-- vix <- sqrt((v1$t * v1$v * ((nt2 - n30) / (nt2 - nt1)) + -->\n\n<!--                v2$t * v2$v * ((n30 - nt1) / (nt2 - nt1))) * (n365 / n30)) -->\n\n<!-- print(vix) -->\n\n<!-- ``` -->\n\n<!-- ## Implied yield -->\n\n<!-- ```{r} -->\n\n<!-- yield_option <- function(type, S, K, r, q, tau, sigma) { -->\n\n<!--     d1 <- bs_d1(S, K, r, q, tau, sigma) -->\n\n<!--     d2 <- bs_d2(S, K, r, q, tau, sigma) -->\n\n<!--     value <- bs_value(type, S, K, r, q, tau, sigma, d1, d2) -->\n\n<!--     if (type == \"call\") { -->\n\n<!--         result <- (value / S) / tau -->\n\n<!--     } else if (type == \"put\") { -->\n\n<!--         result <- (value / K) / tau -->\n\n<!--     } -->\n\n<!--     return(result) -->\n\n<!-- } -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n\n<!-- sigmas <- seq(0.1, 0.3, by = 0.04) -->\n\n<!-- taus <- seq(20, 126, by = 20) / 252 -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n\n<!-- yield_dt <- CJ(sigma = sigmas, tau = taus) -->\n\n<!-- yield_dt[ , yield := yield_option(type, S, K, r, q, tau, sigma), by = c(\"sigma\", \"tau\")] -->\n\n<!-- yield_dt[ , sigma := sigma * 100] -->\n\n<!-- yield_dt[ , tau := tau * scale[[\"periods\"]]] -->\n\n<!-- ``` -->\n\n<!-- ```{r, echo = FALSE, fig.width = 4, fig.height = 3} -->\n\n<!-- yield_plt <- plot_heatmap(yield_dt, x = \"tau\", y = \"sigma\", z = \"yield\", -->\n\n<!--                           title = \"Yield (%)\", xlab = \"Tau\", ylab = \"Sigma\") -->\n\n<!-- print(yield_plt) -->\n\n<!-- ``` -->\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}