{
  "hash": "3bbc11cde639db592cd6403829866d39",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Securities\"\nauthor: \"[Jason Foster](mailto:jason.j.foster@gmail.com)\"\ndate: last-modified\ncategories:\n  - analysis\n  - finance\n  - r\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n# Black-Scholes model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevel_shock <- function(shock, S, tau, sigma) {\n    \n    result <- S * (1 + shock * sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n```\n:::\n\n\n-   <https://en.wikipedia.org/wiki/Greeks_(finance)>\n-   <https://www.wolframalpha.com/input/?i=option+pricing+formula>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor <- \"SP500\"\ntypes <- c(\"call\", \"put\")\nS <- coredata(na.locf(levels_xts[nrow(levels_xts), factor]))\nK <- S\nr <- 0 # use \"USD3MTD156N\"\nq <- 0 # see https://stackoverflow.com/a/11286679 \ntau <- 1 # = 252 / 252\nsigma <- coredata(sd_xts[nrow(sd_xts), factor]) # use \"VIXCLS\"\nshocks <- seq(-3, 3, by = 0.5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt <- CJ(type = types, shock = shocks)\ngreeks_dt[ , spot := level_shock(shock, S, tau, sigma), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n## Value\n\nFor a given spot price $S$, strike price $K$, risk-free rate $r$, annual dividend yield $q$, time-to-maturity $\\tau = T - t$, and volatility $\\sigma$:\n\n$$\n\\begin{aligned}\nV_{c}&=Se^{-q\\tau}\\Phi(d_{1})-e^{-r\\tau}K\\Phi(d_{2}) \\\\\nV_{p}&=e^{-r\\tau}K\\Phi(-d_{2})-Se^{-q\\tau}\\Phi(-d_{1})\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_value <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n  \n    r_df <- exp(-r * tau)\n    q_df <- exp(-q * tau)\n    \n    call_value <- S * q_df * Phi(d1) - r_df * K * Phi(d2)\n    put_value <- r_df * K * Phi(-d2) - S * q_df * Phi(-d1)\n    result <- ifelse(type == \"call\", call_value, put_value)\n    \n    return(result)\n    \n} \n```\n:::\n\n\nwhere\n\n$$\n\\begin{aligned}\nd_{1}&={\\frac{\\ln(S/K)+(r-q+\\sigma^{2}/2)\\tau}{\\sigma{\\sqrt{\\tau}}}} \\\\\nd_{2}&={\\frac{\\ln(S/K)+(r-q-\\sigma^{2}/2)\\tau}{\\sigma{\\sqrt{\\tau}}}}=d_{1}-\\sigma{\\sqrt{\\tau}} \\\\\n\\phi(x)&={\\frac{e^{-{\\frac {x^{2}}{2}}}}{\\sqrt{2\\pi}}} \\\\\n\\Phi(x)&={\\frac{1}{\\sqrt{2\\pi}}}\\int_{-\\infty}^{x}e^{-{\\frac{y^{2}}{2}}}dy=1-{\\frac{1}{\\sqrt{2\\pi}}}\\int_{x}^{\\infty}e^{-{\\frac{y^{2}}{2}}dy}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_d1 <- function(S, K, r, q, tau, sigma) {\n    \n    result <- (log(S / K) + (r - q + sigma ^ 2 / 2) * tau) / (sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n\nbs_d2 <- function(S, K, r, q, tau, sigma) {\n    \n    result <- (log(S / K) + (r - q - sigma ^ 2 / 2) * tau) / (sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n\nphi <- function(x) {\n    \n    result <- dnorm(x)\n    \n    return(result)\n    \n}\n\nPhi <- function(x) {\n    \n    result <- pnorm(x)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , d1 := bs_d1(spot, K, r, q, tau, sigma), by = c(\"type\", \"shock\")]\ngreeks_dt[ , d2 := bs_d2(spot, K, r, q, tau, sigma), by = c(\"type\", \"shock\")]\ngreeks_dt[ , value := bs_value(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n## First-order\n\n### Delta\n\n$$\n\\begin{aligned}\n\\Delta_{c}&={\\frac{\\partial V_{c}}{\\partial S}}=e^{-q\\tau}\\Phi(d_{1}) \\\\\n\\Delta_{p}&={\\frac{\\partial V_{p}}{\\partial S}}=-e^{-q\\tau}\\Phi(-d_{1})\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_delta <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n    \n    q_df <- exp(-q * tau)\n  \n    call_value <- q_df * Phi(d1)\n    put_value <- -q_df * Phi(-d1)\n    result <- ifelse(type == \"call\", call_value, put_value)\n    \n    return(result)\n    \n} \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , delta := bs_delta(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n### Delta-beta\n\nNotional market value is the market value of a leveraged position:\n\n$$\n\\begin{aligned}\n\\text{Equity options }=&\\,\\#\\text{ contracts}\\times\\text{multiple}\\times\\text{spot price}\\\\\n\\text{Delta-adjusted }=&\\,\\#\\text{ contracts}\\times\\text{multiple}\\times\\text{spot price}\\times\\text{delta}\n\\end{aligned}\n$$\n\n-   <https://en.wikipedia.org/wiki/Notional_amount>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_delta_diff <- function(type, S, K, r, q, tau, sigma, delta0) {\n    \n    d1 <- bs_d1(S, K, r, q, tau, sigma)\n    d2 <- bs_d2(S, K, r, q, tau, sigma)\n    delta <- bs_delta(type, S, K, r, q, tau, sigma, d1, d2)\n    \n    call_value <- delta - delta0\n    put_value <- delta0 - delta\n    \n    result <- ifelse(type == \"call\", call_value, put_value)\n        \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta <- 0.35\ntype <- \"call\"\nn <- 1\nmultiple <- 100\ntotal <- 1000000\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- bs_d1(S, K, r, q, tau, sigma)\nd2 <- bs_d2(S, K, r, q, tau, sigma)\nsec <- list(\n    \"n\" = n,\n    \"multiple\" = multiple,\n    \"S\" = S,\n    \"delta\" = bs_delta(type, S, K, r, q, tau, sigma, d1, d2),\n    \"beta\" = 1\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta_dt <- CJ(type = type, shock = shocks)\nbeta_dt[ , spot := level_shock(shock, S, tau, sigma), by = c(\"type\", \"shock\")]\nbeta_dt[ , static := beta]\nbeta_dt[ , diff := bs_delta_diff(type, spot, K, r, q, tau, sigma, sec[[\"delta\"]])]\nbeta_dt[ , dynamic := beta + sec[[\"n\"]] * sec[[\"multiple\"]] * sec[[\"S\"]] * sec[[\"beta\"]] * diff / total, by = c(\"type\", \"shock\")]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=384}\n:::\n:::\n\n\nFor completeness, duration equivalent is defined as:\n\n$$\n\\begin{aligned}\n\\text{10-year equivalent }=\\,&\\frac{\\text{security duration}}{\\text{10-year OTR duration}}\n\\end{aligned}\n$$\n\n### Vega\n\n$$\n\\begin{aligned}\n\\nu_{c,p}&={\\frac{\\partial V_{c,p}}{\\partial\\sigma}}=Se^{-q\\tau}\\phi(d_{1}){\\sqrt{\\tau}}=Ke^{-r\\tau}\\phi(d_{2}){\\sqrt{\\tau}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_vega <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n    \n    q_df <- exp(-q * tau)\n    \n    result <- S * q_df * phi(d1) * sqrt(tau)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , vega := bs_vega(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n### Theta\n\n$$\n\\begin{aligned}\n\\Theta_{c}&=-{\\frac{\\partial V_{c}}{\\partial \\tau}}=-e^{-q\\tau}{\\frac{S\\phi(d_{1})\\sigma}{2{\\sqrt{\\tau}}}}-rKe^{-r\\tau}\\Phi(d_{2})+qSe^{-q\\tau}\\Phi(d_{1}) \\\\\n\\Theta_{p}&=-{\\frac{\\partial V_{p}}{\\partial \\tau}}=-e^{-q\\tau}{\\frac{S\\phi(d_{1})\\sigma}{2{\\sqrt{\\tau}}}}+rKe^{-r\\tau}\\Phi(-d_{2})-qSe^{-q\\tau}\\Phi(-d_{1})\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_theta <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n    \n    r_df <- exp(r * tau)\n    q_df <- exp(q * tau)\n  \n    call_value <- -q_df * S * phi(d1) * sigma / (2 * sqrt(tau)) -\n      r * K * r_df * Phi(d2) + q * S * q_df * Phi(d1)\n    \n    put_value <- -q_df * S * phi(d1) * sigma / (2 * sqrt(tau)) +\n      r * K * r_df * Phi(-d2) - q * S * q_df * Phi(-d1)\n        \n    result <- ifelse(type == \"call\", call_value, put_value)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , theta := bs_theta(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n\n## Second-order\n\n### Gamma\n\n$$\n\\begin{aligned}\n\\Gamma_{c,p}&={\\frac{\\partial\\Delta_{c,p}}{\\partial S}}={\\frac{\\partial^{2}V_{c,p}}{\\partial S^{2}}}=e^{-q\\tau}{\\frac{\\phi(d_{1})}{S\\sigma{\\sqrt{\\tau}}}}=Ke^{-r\\tau}{\\frac{\\phi(d_{2})}{S^{2}\\sigma{\\sqrt{\\tau}}}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_gamma <- function(type, S, K, r, q, tau, sigma, d1, d2) {\n  \n    q_df <- exp(-q * tau)\n    \n    result <- q_df * phi(d1) / (S * sigma * sqrt(tau))\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngreeks_dt[ , gamma := bs_gamma(type, spot, K, r, q, tau, sigma, d1, d2), by = c(\"type\", \"shock\")]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=960}\n:::\n:::\n\n\n# Taylor series\n\n## First-order\n\n### Price-yield formula\n\nFor a function of one variable, $f(x)$, the Taylor series formula is:\n\n$$\n\\begin{aligned}\nf(x+\\Delta x)&=f(x)+{\\frac{f'(x)}{1!}}\\Delta x+{\\frac{f''(x)}{2!}}(\\Delta x)^{2}+{\\frac{f^{(3)}(x)}{3!}}(\\Delta x)^{3}+\\cdots+{\\frac{f^{(n)}(x)}{n!}}(\\Delta x)^{n}+\\cdots\\\\\nf(x+\\Delta x)-f(x)&={\\frac{f'(x)}{1!}}\\Delta x+{\\frac{f''(x)}{2!}}(\\Delta x)^{2}+{\\frac{f^{(3)}(x)}{3!}}(\\Delta x)^{3}+\\cdots+{\\frac{f^{(n)}(x)}{n!}}(\\Delta x)^{n}+\\cdots\n\\end{aligned}\n$$\n\nUsing the price-yield formula, the estimated percentage change in price for a change in yield is:\n\n$$\n\\begin{aligned}\nP(y+\\Delta y)-P(y)&\\approx{\\frac{P'(y)}{1!}}\\Delta y+{\\frac{P''(y)}{2!}}(\\Delta y)^{2}\\\\\n&\\approx -D\\Delta y +{\\frac{C}{2!}}(\\Delta y)^{2}\n\\end{aligned}\n$$\n\nBecause of market conventions, use the following formula: $P(y+\\Delta y)-P(y)\\approx -D\\Delta y +{\\frac{C\\times 100}{2!}}(\\Delta y)^{2}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnl_bond <- function(duration, convexity, dy) {\n    \n    duration_pnl <- -duration * dy\n    convexity_pnl <- (convexity * 100 / 2) * dy ^ 2\n    income_pnl <- dy\n    \n    result <- list(\"total\" = duration_pnl + convexity_pnl + income_pnl,\n                   \"duration\" = duration_pnl,\n                   \"convexity\" = convexity_pnl,\n                   \"income\" = income_pnl)\n    \n    return(result)\n    \n} \n```\n:::\n\n\n-   <https://engineering.nyu.edu/sites/default/files/2021-07/CarWuRF2021.pdf>\n-   <https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118267967.app1>\n-   <https://www.investopedia.com/terms/c/convexity-adjustment.asp>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor <- \"DGS10\"\nduration <- 6.5\nconvexity <- 0.65\ny <- coredata(tail(na.locf(levels_xts[ , factor]), width)[1])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbonds_dt <- data.table(index = index(tail(levels_xts, width)),\n                       duration = duration, convexity = convexity,\n                       dy = na.locf(tail(levels_xts[ , factor], width)))\nsetnames(bonds_dt, c(\"index\", \"duration\", \"convexity\", \"dy\"))\nbonds_dt[ , dy := (dy - y) / 100, by = index]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattrib_dt <- bonds_dt[ , as.list(unlist(pnl_bond(duration, convexity, dy))), by = index]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=576}\n:::\n:::\n\n\n### Duration-yield formula\n\nThe derivative of duration with respect to interest rates gives:\n\n$$\n\\begin{aligned}\n\\text{Drift}&=-\\frac{\\partial D}{\\partial y}\\\\\n&=\\frac{1}{P}\\frac{\\partial^{2}P}{\\partial y^{2}}-\\frac{1}{P^{2}}\\frac{\\partial P}{\\partial y}\\frac{\\partial P}{\\partial y}\\\\\n&=C-D^{2}\n\\end{aligned}\n$$\n\nBecause of market conventions, use the following formula: $\\text{Drift}=\\frac{1}{100}\\left(C\\times 100-D^{2}\\right)=C-\\frac{D^{2}}{100}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyield_shock <- function(shock, tau, sigma) {\n    \n    result <- shock * sigma * sqrt(tau)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nduration_drift <- function(duration, convexity, dy) {\n    \n    drift <- convexity - duration ^ 2 / 100\n    change <- -drift * dy * 100\n    \n    result <- list(\"drift\" = drift,\n                   \"change\" = change)\n    \n    return(result)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# \"Risk Management: Approaches for Fixed Income Markets\" (page 45)\nfactor <- \"DGS10\"\nsigma <- coredata(sd_xts[nrow(sd_xts), factor])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nduration_dt <- CJ(shock = shocks)\nduration_dt[ , spot := yield_shock(shock, tau, sigma), by = \"shock\"]\nduration_dt[ , static := duration]\nduration_dt[ , dynamic := duration + duration_drift(duration, convexity, spot)[[\"change\"]], by = \"shock\"]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=384}\n:::\n:::\n\n\n## Second-order\n\n### Black's formula\n\nA similar formula holds for functions of several variables $f(x_{1},\\ldots,x_{n})$. This is usually written as:\n\n$$\n\\begin{aligned}\nf(x_{1}+\\Delta x_{1},\\ldots,x_{n}+\\Delta x_{n})&=f(x_{1},\\ldots, x_{n})+ \\sum _{j=1}^{n}{\\frac{\\partial f(x_{1},\\ldots,x_{n})}{\\partial x_{j}}}(\\Delta x_{j})\\\\\n&+{\\frac {1}{2!}}\\sum_{j=1}^{n}\\sum_{k=1}^{n}{\\frac{\\partial^{2}f(x_{1},\\ldots,x_{d})}{\\partial x_{j}\\partial x_{k}}}(\\Delta x_{j})(\\Delta x_{k})+\\cdots\n\\end{aligned}\n$$\n\nUsing Black's formula, the estimated change of an option price is:\n\n$$\n\\begin{aligned}\nV(S+\\Delta S,\\sigma+\\Delta\\sigma,t+\\Delta t)-V(S,\\sigma,t)&\\approx{\\frac{\\partial V}{\\partial S}}\\Delta S+{\\frac{1}{2!}}{\\frac{\\partial^{2}V}{\\partial S^{2}}}(\\Delta S)^{2}+{\\frac{\\partial V}{\\partial \\sigma}}\\Delta\\sigma+{\\frac{\\partial V}{\\partial t}}\\Delta t\\\\\n&\\approx \\Delta_{c,p}\\Delta S+{\\frac{1}{2!}}\\Gamma_{c,p}(\\Delta S)^{2}+\\nu_{c,p}\\Delta\\sigma+\\Theta_{c,p}\\Delta t\n\\end{aligned}\n$$\n\n-   <https://quant-next.com/option-greeks-and-pl-decomposition-part-1/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnl_option <- function(type, S, K, r, q, tau, sigma, dS, dt, dsigma) {\n    \n    d1 <- bs_d1(S, K, r, q, tau, sigma)\n    d2 <- bs_d2(S, K, r, q, tau, sigma)\n    value <- bs_value(type, S, K, r, q, tau, sigma, d1, d2)\n    delta <- bs_delta(type, S, K, r, q, tau, sigma, d1, d2)\n    vega <- bs_vega(type, S, K, r, q, tau, sigma, d1, d2)\n    theta <- bs_theta(type, S, K, r, q, tau, sigma, d1, d2)\n    gamma <- bs_gamma(type, S, K, r, q, tau, sigma, d1, d2)\n    \n    delta_pnl <- delta * dS / value\n    gamma_pnl <- gamma / 2 * dS ^ 2 / value\n    vega_pnl <- vega * dsigma / value\n    theta_pnl <- theta * dt / value\n    \n    result <- list(\"total\" = delta_pnl + gamma_pnl + vega_pnl + theta_pnl,\n                   \"delta\" = delta_pnl,\n                   \"gamma\" = gamma_pnl,\n                   \"vega\" = vega_pnl,\n                   \"theta\" = theta_pnl)\n    \n    return(result)    \n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor <- \"SP500\"\ntype <- \"call\"\nS <- coredata(tail(na.locf(levels_xts[ , factor]), width)[1])\nK <- S # * (1 + 0.05)\ntau <- 1 # = 252 / 252\nsigma <- coredata(tail(sd_xts[ , factor], width)[1])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noptions_dt <- data.table(index = index(tail(levels_xts, width)),\n                         spot = na.locf(tail(levels_xts[ , factor], width)),\n                         sigma = tail(sd_xts[ , factor], width))\nsetnames(options_dt, c(\"index\", \"spot\", \"sigma\"))\noptions_dt[ , dS := spot - S, by = index]\noptions_dt[ , dt_diff := as.numeric(index - index[1])]\noptions_dt[ , dt := dt_diff / tail(dt_diff, 1)]\noptions_dt[ , dsigma := sigma - ..sigma, by = index]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattrib_dt <- options_dt[ , as.list(unlist(pnl_option(type, S, K, r, q, tau, ..sigma,\n                                                     dS, dt, dsigma))), by = index]\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=576}\n:::\n:::\n\n\n### Ito's lemma\n\nFor a given diffiusion $X(t, w)$ driven by:\n\n$$\n\\begin{aligned}\ndX_{t}&=\\mu_{t}dt+\\sigma_{t}dB_{t}\n\\end{aligned}\n$$\n\nThen proceed with the Taylor series for a function of two variables $f(t,x)$:\n\n$$\n\\begin{aligned}\ndf&={\\frac{\\partial f}{\\partial t}}dt+{\\frac{\\partial f}{\\partial x}}dx+{\\frac{1}{2}}{\\frac{\\partial^{2}f}{\\partial x^{2}}}dx^{2}\\\\\n&={\\frac{\\partial f}{\\partial t}}dt+{\\frac{\\partial f}{\\partial x}}(\\mu_{t}dt+\\sigma_{t}dB_{t})+{\\frac{1}{2}}{\\frac{\\partial^{2}f}{\\partial x^{2}}}\\left(\\mu_{t}^{2}dt^{2}+2\\mu_{t}\\sigma _{t}dtdB_{t}+\\sigma_{t}^{2}dB_{t}^{2}\\right)\\\\\n&=\\left({\\frac{\\partial f}{\\partial t}}+\\mu_{t}{\\frac{\\partial f}{\\partial x}}+{\\frac{\\sigma _{t}^{2}}{2}}{\\frac{\\partial ^{2}f}{\\partial x^{2}}}\\right)dt+\\sigma_{t}{\\frac{\\partial f}{\\partial x}}dB_{t}\n\\end{aligned}\n$$\n\nNote: set the $dt^{2}$ and $dtdB_{t}$ terms to zero and substitute $dt$ for $dB^{2}$.\n\n### Geometric Brownian motion\n\nThe most common application of Ito's lemma in finance is to start with the percent change of an asset:\n\n$$\n\\begin{aligned}\n\\frac{dS}{S}&=\\mu_{t}dt+\\sigma_{t}dB_{t}\n\\end{aligned}\n$$\n\nThen apply Ito's lemma with $f(S)=log(S)$:\n\n$$\n\\begin{aligned}\nd\\log(S)&=f^{\\prime}(S)dS+{\\frac{1}{2}}f^{\\prime\\prime}(S)S^{2}\\sigma^{2}dt\\\\\n&={\\frac {1}{S}}\\left(\\sigma SdB+\\mu Sdt\\right)-{\\frac{1}{2}}\\sigma^{2}dt\\\\\n&=\\sigma dB+\\left(\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right)dt\n\\end{aligned}\n$$\n\nIt follows that:\n\n$$\n\\begin{aligned}\n\\log(S_{t})-\\log(S_{0})=\\sigma dB+\\left(\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right)dt\n\\end{aligned}\n$$\n\nExponentiating gives the expression for $S$:\n\n$$\n\\begin{aligned}\nS_{t}=S_{0}\\exp\\left(\\sigma B_{t}+\\left(\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right)t\\right)\n\\end{aligned}\n$$\n\nThis provides a recursive procedure for simulating values of $S$ at $t_{0}<t_{1}<\\cdots<t_{n}$:\n\n$$\n\\begin{aligned}\nS(t_{i+1})&=S(t_{i})\\exp\\left(\\sigma\\sqrt{t_{i+1}-t_{i}}Z_{i+1}+\\left[\\mu-{\\tfrac{\\sigma^{2}}{2}}\\right]\\left(t_{i+1}-t_{i}\\right)\\right)\n\\end{aligned}\n$$\n\nwhere $Z_{1},Z_{2},\\ldots,Z_{n}$ are independent standard normals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_gbm <- function(n_sim, S, mu, sigma, dt) {\n    \n    result <- S * exp(cumsum(sigma * sqrt(dt) * rnorm(n_sim)) +\n                      (mu - 0.5 * sigma ^ 2) * dt)\n    \n    return(result)\n    \n}\n```\n:::\n\n\nThis leads to an algorithm for simulating a multidimensional geometric Brownian motion:\n\n$$\n\\begin{aligned}\nS_{k}(t_{i+1})&=S_{k}(t_{i})\\exp\\left(\\sqrt{t_{i+1}-t_{i}}\\sum_{j=1}^{d}{A_{kj}Z_{i+1,j}}+\\left[\\mu_{k}-{\\tfrac{\\sigma_{k}^{2}}{2}}\\right]\\left(t_{i+1}-t_{i}\\right)\\right)\n\\end{aligned}\n$$\n\nwhere $A$ is the Cholesky factor of $\\Sigma$, i.e. $A$ is any matrix for which $AA^\\mathrm{T}=\\Sigma$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_multi_gbm <- function(n_sim, S, mu, sigma, dt) {\n    \n    n_cols <- ncol(sigma)\n    \n    Z <- matrix(rnorm(n_sim * n_cols), nrow = n_sim, ncol = n_cols)\n    X <- sweep(sqrt(dt) * (Z %*% chol(sigma)), 2, (mu - 0.5 * diag(sigma)) * dt, \"+\")\n    \n    result <- sweep(apply(X, 2, function(x) exp(cumsum(x))), 2, S, \"*\")\n    \n    return(result)\n    \n}\n```\n:::\n\n\n-   <https://arxiv.org/pdf/0812.4210.pdf>\n-   <https://quant.stackexchange.com/questions/15219/calibration-of-a-gbm-what-should-dt-be>\n-   <https://stackoverflow.com/questions/36463227/geometrical-brownian-motion-simulation-in-r>\n-   <https://quant.stackexchange.com/questions/25219/simulate-correlated-geometric-brownian-motion-in-the-r-programming-language>\n-   <https://quant.stackexchange.com/questions/35194/estimating-the-historical-drift-and-volatility/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nS <- rep(1, length(factors))\nsigma <- cov(returns_xts, use = \"complete.obs\") * scale[[\"periods\"]]\nmu <- colMeans(na.omit(returns_xts)) * scale[[\"periods\"]]\nmu <- mu + diag(sigma) / 2 # drift\ndt <- 1 / scale[[\"periods\"]]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmu_ls <- list()\nsigma_ls <- list()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:1e4) {\n    \n    # assumes stock prices\n    levels_sim <- sim_multi_gbm(width + 1, S, mu, sigma, dt)\n    returns_sim <- diff(log(levels_sim))\n\n    mu_sim <- colMeans(returns_sim) * scale[[\"periods\"]]\n    sigma_sim <- apply(returns_sim, 2, sd) * sqrt(scale[[\"periods\"]])\n    \n    mu_ls <- append(mu_ls, list(mu_sim))\n    sigma_ls <- append(sigma_ls, list(sigma_sim))\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\"empirical\" = colMeans(na.omit(returns_xts)) * scale[[\"periods\"]],\n           \"theoretical\" = colMeans(do.call(rbind, mu_ls)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 empirical   theoretical\nSP500         0.0937458341  0.0939589540\nDTWEXAFEGS    0.0148843950  0.0151024942\nDGS10        -0.0003912031 -0.0004243392\nBAMLH0A0HYM2  0.0012931436  0.0013670951\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\"empirical\" = sqrt(diag(sigma)),\n           \"theoretical\" = colMeans(do.call(rbind, sigma_ls)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               empirical theoretical\nSP500        0.179643204 0.179549328\nDTWEXAFEGS   0.062553292 0.062490688\nDGS10        0.008250708 0.008238126\nBAMLH0A0HYM2 0.016966097 0.016945038\n```\n\n\n:::\n:::\n\n\n### Vasicek model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assumes interest rates follow mean-reverting process with stochastic volatility\n```\n:::\n\n\n# Newton's method\n\n## Implied volatility\n\nNewton's method (main idea is also from a Taylor series) is a method for finding approximations to the roots of a function $f(x)$:\n\n$$\n\\begin{aligned}\nx_{n+1}=x_{n}-{\\frac{f(x_{n})}{f'(x_{n})}}\n\\end{aligned}\n$$\n\nTo solve $V(\\sigma_{n})-V=0$ for $\\sigma_{n}$, use Newton's method and repeat until $\\left|\\sigma_{n+1}-\\sigma_{n}\\right|<\\varepsilon$:\n\n$$\n\\begin{aligned}\n\\sigma_{n+1}=\\sigma_{n}-{\\frac{V(\\sigma_{n})-V}{V'(\\sigma_{n})}}\n\\end{aligned}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_newton <- function(params, type, S, K, r, q, tau) {\n    \n    target0 <- 0\n    sigma <- params[[\"sigma\"]]\n    sigma0 <- sigma\n    \n    while (abs(target0 - params[[\"target\"]]) > params[[\"tol\"]]) {\n        \n        d1 <- bs_d1(S, K, r, q, tau, sigma0)\n        d2 <- bs_d2(S, K, r, q, tau, sigma0)\n        \n        target0 <- bs_value(type, S, K, r, q, tau, sigma0, d1, d2)\n        vega0 <- bs_vega(type, S, K, r, q, tau, sigma0, d1, d2)\n        \n        sigma <- sigma0 - (target0 - params[[\"target\"]]) / vega0\n        sigma0 <- sigma\n        \n    }\n    \n    return(sigma)\n    \n}\n```\n:::\n\n\n-   <http://www.aspenres.com/documents/help/userguide/help/bopthelp/bopt2Implied_Volatility_Formula.html>\n-   <https://books.google.com/books?id=VLi61POD61IC&pg=PA104>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nS <- coredata(na.locf(levels_xts)[nrow(levels_xts), factor])\nK <- S # * (1 + 0.05)\nsigma <- coredata(sd_xts[nrow(sd_xts), factor]) # overrides matrix\nstart <- 0.2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- bs_d1(S, K, r, q, tau, sigma)\nd2 <- bs_d2(S, K, r, q, tau, sigma)\ntarget <- bs_value(type, S, K, r, q, tau, sigma, d1, d2)\nparams <- list(\n    \"target\" = target,\n    \"sigma\" = start,\n    \"tol\" = 1e-4 # .Machine$double.eps\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_newton(params, type, S, K, r, q, tau)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         SP500\n[1,] 0.1320575\n```\n\n\n:::\n:::\n\n\n## Yield-to-maturity\n\n# Optimization\n\n## Implied volatility\n\nIf the derivative is unknown, try optimization:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_obj <- function(param, type, S, K, r, q, tau, target) {\n    \n    d1 <- bs_d1(S, K, r, q, tau, param)\n    d2 <- bs_d2(S, K, r, q, tau, param)\n    target0 <- bs_value(type, S, K, r, q, tau, param, d1, d2)\n    \n    result <- abs(target0 - target)\n    \n    return(result)\n    \n}\n\nimplied_vol_optim <- function(param, type, S, K, r, q, tau, target) {\n    \n    result <- optim(param, implied_vol_obj, type = type, S = S, K = K, r = r, q = q,\n                    tau = tau, target = target, method = \"Brent\", lower = 0, upper = 1)\n    \n    return(result$par)\n    \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nimplied_vol_optim(start, type, S, K, r, q, tau, target)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1320575\n```\n\n\n:::\n:::\n\n\n## Yield-to-maturity\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}